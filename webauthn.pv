(* ProVerif Web Authentication Formal Model: webauthn.pv
   based on webauthn-basic.pv by Iness Ben Guirat
   Paper: https://dl.acm.org/doi/10.1145/3190619.3190640 (by Iness Ben Guirat and Harry Halpin)
   Slides: https://cps-vo.org/node/48511
   github: https://github.com/hhalpin/weauthn-model
   ------
   [MANUAL]: The proverif manual is here: https://prosecco.gforge.inria.fr/personal/bblanche/proverif/manual.pdf
*)

(* INTRODUCTION:

See the paper section 5.2 for a detailed description of the original model.

This models a registration of a WebAuthn user credential with a server (aka Relying Party) and then models subsequent authentication using that registered credential.  The model seeks to prove various properties of the protocol.

This current model is by Jeff Hodges, July 2021
http://kingsmountain.com/people/jeff.hodges/

*)
set traceDisplay = long.


#include "crypto.pvl"
#include "named_tuples.pvl"


(* Comms Channel *)

free c: channel.  (* TLS channel *)

free tlsKey: Key [private].  (* TLS symmetric encryption key *)


(* Various locally-defined types                                            *)
(* (see crypto.pvl and named_tuples.pvl for types not defined in this file) *)

type nonce.


(* Server's ID *)

type RP_id.
const a: RP_id (* [private] *).
type Extensions. (* placeholder for now *)

(* Attestation Key Pair *)

free attSecretKey: SKey [private].
free attPublicKey: PKey (* [private] *). (* an attacker can obtain the attPublicKey from several sources,
                                            e.g.: an authenticator itself, or authenticator metadata *)


(* Server's and authnr+clientPlatform's tuple messages *)

(** Registration Request message -- server sends this to the user's authnr+clientPlatform: **)

DEFINE_DATA_TYPE3(RegRequestMsg,
                  regChallenge, nonce,
                  serverName, RP_id,
                  extensions, Extensions).

fun RegRequestMsg2b( RegRequestMsg ): bitstring [data, typeConverter].
fun B2RegRequestMsg( bitstring ): RegRequestMsg [data, typeConverter].


(** Registration Response message -- Attestation Statement, Authenticator Data, and Attestation Object: **)

DEFINE_DATA_TYPE2(AttStatement,
                  attSignature, bitstring,
                  attPublicKey, PKey).

fun AttStatement2b( AttStatement ): bitstring [data, typeConverter].
fun B2AttStatement( bitstring ): AttStatement [data, typeConverter].


(*
fun BuildExtensions(bitstring): Extensions [data].
reduc forall devicePublicKey: bitstring;
    Extensions_devicePublicKey(BuildExtensions(devicePublicKey)) = devicePublicKey.
*)

DEFINE_DATA_TYPE3(AuthData,
                  serverName, RP_id,
                  userCredPubKey, PKey,
                  extensions, Extensions).

fun AuthData2b( AuthData ): bitstring [data, typeConverter].
fun B2AuthData( bitstring ): AuthData [data, typeConverter].


DEFINE_DATA_TYPE2(AttObject,
                  attStatement, AttStatement,
                  authData, AuthData).

fun AttObject2b( AttObject ): bitstring [data, typeConverter].
fun B2AttObject( bitstring ): AttObject [data, typeConverter].



(** Registration Response message: AuthenticatorAttestationResponse -- authnr+clientPlatform returns this to server: **)

DEFINE_DATA_TYPE2(AuthnrAttResponseMsg,
                  challenge, nonce,
                  attObject, AttObject).

fun AuthnrAttResponseMsg2b( AuthnrAttResponseMsg ): bitstring [data, typeConverter].
fun B2AuthnrAttResponseMsg( bitstring ): AuthnrAttResponseMsg [data, typeConverter].


(** Authentication Request message -- server sends this to the client: **)
DEFINE_DATA_TYPE2(AuthnRequestMsg,
                  authnChallenge, nonce,
                  serverName, RP_id).

fun AuthnRequestMsg2b( AuthnRequestMsg ): bitstring [data, typeConverter].
fun B2AuthnRequestMsg( bitstring ): AuthnRequestMsg [data, typeConverter].


(** Authentication Response message -- user's authnr+clientPlatform returns this to server: **)
DEFINE_DATA_TYPE3(AuthnResponseMsg,
                  returnedAuthnChallenge, nonce,
                  serverName, RP_id,
                  assertSignature, bitstring).

fun AuthnResponseMsg2b( AuthnResponseMsg ): bitstring [data, typeConverter].
fun B2AuthnResponseMsg( bitstring ): AuthnResponseMsg [data, typeConverter].


(* Events and Queries *)

event sendingAuthnResponse(bitstring).
event receivedValidAuthnResponse(bitstring).

(** we can only receive a valid response if the user's authnr+clientPlatform sent the response message,
    and we have to receive the same message as was sent. **)
query msg:bitstring, msg':bitstring;
    event(receivedValidAuthnResponse(msg)) && event(sendingAuthnResponse(msg')) ==> msg = msg'.


query   attacker(attSecretKey).
query   attacker(attPublicKey).
query   attacker(tlsKey).

query   secret regChallengeQ;   (* secrecy queries (see "5.1.2 Security properties" in [MANUAL]) *)
        secret authnChallengeQ.



(* Processes *)

let processClientAndAuthnr ( k: Key, attskU: SKey, attpkU: PKey) =

    (** Registration **)

    in(c, encRegRequestMsg: bitstring);             (* receive and parse registration request msg *)
    let regRequestMsgb = dec(encRegRequestMsg, k) in
    let regRequestMsg = B2RegRequestMsg(regRequestMsgb) in
    let receivedRegChallenge = RegRequestMsg_regChallenge(regRequestMsg) in
    let receivedServerName = RegRequestMsg_serverName(regRequestMsg) in
    let receivedExtensions = RegRequestMsg_extensions(regRequestMsg) in

    new skU: SKey;                                  (* mint new user credential "secret key user" |skU| *)
    let pkU = pk(skU) in                            (* and "public key user" |pkU|                      *)
    new extensionsOutputs: Extensions;

    let authData = BuildAuthData(receivedServerName, pkU, extensionsOutputs) in  (* construct attestation object *)
    let attSignature = sign( (authData, receivedRegChallenge), attskU ) in
    let attStatement = BuildAttStatement(attSignature, attpkU) in
    let attObject = BuildAttObject(attStatement, authData) in

    let authnrAttResponseMsg = BuildAuthnrAttResponseMsg(receivedRegChallenge, attObject) in
    let authnrAttResponseMsgb = AuthnrAttResponseMsg2b(authnrAttResponseMsg) in

    let encAuthnrAttResponseMsg = enc(authnrAttResponseMsgb, k) in

    out(c, encAuthnrAttResponseMsg);                (* return registration response with attestation *)


    (** Authentication **)

    in(c, encAuthnRequestMsg: bitstring);           (* receive server's challenge. *)

    let authnRequestMsgb = dec(encAuthnRequestMsg, k) in
    let authnRequestMsg = B2AuthnRequestMsg(authnRequestMsgb) in
    let receivedAuthnChallenge = AuthnRequestMsg_authnChallenge(authnRequestMsg) in
    let receivedServerName = AuthnRequestMsg_serverName(authnRequestMsg) in

    let assertionSignature = sign((receivedAuthnChallenge, receivedServerName), skU) in

    let authnResponseMsg = BuildAuthnResponseMsg(receivedAuthnChallenge, receivedServerName, assertionSignature) in
    let authnResponseMsgb = AuthnResponseMsg2b(authnResponseMsg) in

    let encAuthnResponseMsgFromAuthnr = enc(authnResponseMsgb, k) in

    event sendingAuthnResponse( encAuthnResponseMsgFromAuthnr );

    out(c, encAuthnResponseMsgFromAuthnr).            (* return authn response *)



let processServer (k: Key, a: RP_id) =

    (** Registration **)

    new regChallenge: nonce;
    new requestedExtensions: Extensions;

    let regRequestMsg = BuildRegRequestMsg(regChallenge, a, requestedExtensions) in
    let regRequestMsgb = RegRequestMsg2b(regRequestMsg) in

    out(c, enc(regRequestMsgb, k));        (* send registration request *)

    (* --- wait for client -- *)

    in(c, encAuthnrAttResponseMsg: bitstring);      (* receive possible registration response *)

    let authnrAttResponseMsgb = dec(encAuthnrAttResponseMsg, k) in              (* decrypt and parse |encAuthnrAttResponseMsg| *)
    let authnrAttResponseMsg = B2AuthnrAttResponseMsg(authnrAttResponseMsgb) in

    let returnedRegChallenge = AuthnrAttResponseMsg_challenge(authnrAttResponseMsg) in
    let returnedAttObject = AuthnrAttResponseMsg_attObject(authnrAttResponseMsg) in (* extract AttObject *)

    let returnedAttStatement = AttObject_attStatement(returnedAttObject) in         (* extract and parse AttStatement *)
    let attSig = AttStatement_attSignature(returnedAttStatement) in
    let attPK = AttStatement_attPublicKey(returnedAttStatement) in

    let returnedAuthData = AttObject_authData(returnedAttObject) in                 (* extract and parse AuthData *)
    let returnedServerName = AuthData_serverName(returnedAuthData) in
    let userPK = AuthData_userCredPubKey(returnedAuthData) in
    let returnedExtensions = AuthData_extensions(returnedAuthData) in


    if checkSign(attSig, (returnedAuthData, returnedRegChallenge), attPK) then (* we have a registration response msg with
                                                                                  a valid signature... *)

    if (regChallenge = returnedRegChallenge) then (                         (* ...and if the challenge returned matches the
                                                                                  one we sent, we will proceed to challenge
                                                                                  the user to authenticate. *)
        (** Authentication **)

        new authnChallenge: nonce;

        (* let authnChallengeBitstr = nonce_to_bitstring( authnChallenge ) in  -- do we need to do this type conversion? *)

        let authnRequestMsg = BuildAuthnRequestMsg(authnChallenge, a) in
        let authnRequestMsgb = AuthnRequestMsg2b(authnRequestMsg) in

        out(c, enc(authnRequestMsgb, k) );                                  (* send authentication request *)

        (* --- wait for client -- *)

        in(c, encAuthnResponseMsg: bitstring);                              (* receive authn response *)

        let authnResponseMsgb = dec(encAuthnResponseMsg, k) in              (* decrypt and parse |encAuthnResponseMsg| *)
        let authnResponseMsg = B2AuthnResponseMsg(authnResponseMsgb) in
        let retAuthnChallenge = AuthnResponseMsg_returnedAuthnChallenge(authnResponseMsg) in
        let retServerName = AuthnResponseMsg_serverName(authnResponseMsg) in
        let retAssertSignature = AuthnResponseMsg_assertSignature(authnResponseMsg) in

        if (authnChallenge = retAuthnChallenge) && (a = retServerName) then
        if checkSign(retAssertSignature, (retAuthnChallenge, retServerName), userPK) then

        event receivedValidAuthnResponse(encAuthnResponseMsg);

        (* set up for secrecy queries (see "5.1.2 Security properties" in [MANUAL]) *)
        let regChallengeQ = regChallenge in
        let authnChallengeQ = authnChallenge

    ).



process
  new tlsKey: Key; (** assume TLS handshake is error-free and yields this symmetric channel-encryption key **)
  new attSecretKey: SKey; (** assume a particular authenticator with a particular attestation private key **)

  let attPublicKey = pk(attSecretKey) in
  (
    !processClientAndAuthnr(tlsKey, attSecretKey, attPublicKey) | !processServer(tlsKey, a)
  )


(** END **)
