(* ProVerif Web Authentication Formal Model: webauthn.pv
   based on webauthn-basic.pv by Iness Ben Guirat
   Paper: https://dl.acm.org/doi/10.1145/3190619.3190640 (by Iness Ben Guirat and Harry Halpin)
   Slides: https://cps-vo.org/node/48511
   github: https://github.com/hhalpin/weauthn-model
*)

(* INTRODUCTION:

See the paper section 5.2 for a detailed description of the original model.

This models a registration of a WebAuthn user credential with a server (aka Relying Party) and then models subsequent authentication using that registered credential.  The model seeks to prove various properties of the protocol.

This current model is by Jeff Hodges, July 2021
http://kingsmountain.com/people/jeff.hodges/

*)


#include "crypto.pvl"
#include "named_tuples.pvl"


(* Comms Channel *)

free c: channel.  (* TLS channel *)

free tlsKey: Key [private].  (* TLS symmetric encryption key *)


(* Various locally-defined types                                            *)
(* (see crypto.pvl and named_tuples.pvl for types not defined in this file) *)

type nonce.


(* Server's ID *)

type RP_id.
const a: RP_id [private].


(* Attestation Key Pair *)

free attSecretKey: SKey [private].
free attPublicKey: PKey [private].


(* Server's and authnr+clientPlatform's tuple messages *)

(** Registration Request message -- server sends this to the user's authnr+clientPlatform: **)
DEFINE_DATA_TYPE2(RegRequestMsg,
                  regChallenge, nonce,
                  serverName, RP_id).

fun RegRequestMsg2b( RegRequestMsg ): bitstring [data, typeConverter].
fun B2RegRequestMsg( bitstring ): RegRequestMsg [data, typeConverter].


(** Registration Response message -- authnr+clientPlatform returns this to server: **)
DEFINE_DATA_TYPE4(RegResponseMsg,
                  userCredPubKey, PKey,
                  attPublicKey, PKey,
                  receivedRegChallenge, nonce,
                  attSignature, bitstring).

fun RegResponseMsg2b( RegResponseMsg ): bitstring [data, typeConverter].
fun B2RegResponseMsg( bitstring ): RegResponseMsg [data, typeConverter].



(** Authentication Request message -- server sends this to the client: **)
DEFINE_DATA_TYPE2(AuthnRequestMsg,
                  authnChallenge, nonce,
                  serverName, RP_id).

fun AuthnRequestMsg2b( AuthnRequestMsg ): bitstring [data, typeConverter].
fun B2AuthnRequestMsg( bitstring ): AuthnRequestMsg [data, typeConverter].


(** Authentication Response message -- user's authnr+clientPlatform returns this to server: **)
DEFINE_DATA_TYPE3(AuthnResponseMsg,
                  returnedAuthnChallenge, nonce,
                  serverName, RP_id,
                  assertSignature, bitstring).

fun AuthnResponseMsg2b( AuthnResponseMsg ): bitstring [data, typeConverter].
fun B2AuthnResponseMsg( bitstring ): AuthnResponseMsg [data, typeConverter].


(* Events and Queries *)

event sentChallengeResponse(bitstring, bitstring).
event validChallengeResponse(bitstring, bitstring).

(** we can only receive a valid response if the user's authnr+clientPlatform sent a response message **)
query N:bitstring, s:bitstring; event(validChallengeResponse(N, s)) ==> event(sentChallengeResponse(N, s)).

(** This was in the original model, am not sure what the intent was...
query N:bitstring; event(reachAuthentication(N)).
event reachAuthentication(bitstring). **)

query attacker(attSecretKey).
query attacker(attPublicKey).
query attacker(tlsKey).



(* Processes *)

let processClientAndAuthnr ( k: Key, attskU: SKey, attpkU: PKey) =

    (** Registration **)

    in(c, encRegRequestMsg:bitstring);
    let regRequestMsgb = dec(encRegRequestMsg, k) in
    let regRequestMsg = B2RegRequestMsg(regRequestMsgb) in
    let receivedRegChallenge = RegRequestMsg_regChallenge(regRequestMsg) in
    let receivedServerName = RegRequestMsg_serverName(regRequestMsg) in

    new skU: SKey;          (* mint new user credential "secret key user" |skU| *)
    let pkU = pk(skU) in    (* and "public key user" |pkU|                      *)

    let regResponseMsg = BuildRegResponseMsg(pkU, attpkU, receivedRegChallenge, sign((pkU, receivedRegChallenge), attskU)) in
    let regResponseMsgb = RegResponseMsg2b(regResponseMsg) in

    out(c,                  (* return registration response with attestation *)
        enc(regResponseMsgb, k)
       );


    (** Authentication **)

    in(c, encAuthnRequestMsg: bitstring);   (* receive server's challenge. *)
    let authnRequestMsgb = dec(encAuthnRequestMsg, k) in
    let authnRequestMsg = B2AuthnRequestMsg(authnRequestMsgb) in
    let receivedAuthnChallenge = AuthnRequestMsg_authnChallenge(authnRequestMsg) in
    let receivedServerName = AuthnRequestMsg_serverName(authnRequestMsg) in

    let assertionSignature = sign((receivedAuthnChallenge, receivedServerName), skU) in
    let authnResponseMsg = BuildAuthnResponseMsg(receivedAuthnChallenge, receivedServerName, assertionSignature) in
    let authnResponseMsgb = AuthnResponseMsg2b(authnResponseMsg) in

    event sentChallengeResponse( authnResponseMsgb, enc(authnResponseMsgb, k) );
    out(c,
        enc(authnResponseMsgb, k)
       ).



let processServer (k: Key, a: RP_id) =

    (** Registration **)

    new regChallenge: nonce;

    out(c, enc((regChallenge, a), k));        (* send registration request *)
    in(c, encRegResponseMsg: bitstring);      (* receive possible registration response *)

    let regResponseMsgb = dec(encRegResponseMsg, k) in (* decrypt and parse |encRegResponseMsg| *)
    let regResponseMsg = B2RegResponseMsg(regResponseMsgb) in
    let userPK = RegResponseMsg_userCredPubKey(regResponseMsg) in
    let attPK = RegResponseMsg_attPublicKey(regResponseMsg) in
    let returnedRegChallenge = RegResponseMsg_receivedRegChallenge(regResponseMsg) in
    let attSig = RegResponseMsg_attSignature(regResponseMsg) in

    if checkSign(attSig, (userPK, returnedRegChallenge), attPK) then (* we have a registration response msg with
                                                                        a valid signature... *)

    if (regChallenge = returnedRegChallenge) then (  (* ...and if the challenge returned matches the  then we
                                                          one we sent, we will proceed to challenge the user to
                                                          authenticate. *)

        (** Authentication **)

        new authnChallenge: nonce;

        (* let authnChallengeBitstr = nonce_to_bitstring( authnChallenge ) in  -- do we need to do this type conversion? *)

        let authnRequestMsg = BuildAuthnRequestMsg(authnChallenge, a) in
        let authnRequestMsgb = AuthnRequestMsg2b(authnRequestMsg) in

        out(c, enc( authnRequestMsgb, k) );     (* send authentication request *)

        in(c, encAuthnResponseMsg: bitstring);
        let authnResponseMsgb = dec(encAuthnResponseMsg, k) in
        let authnResponseMsg = B2AuthnResponseMsg(authnResponseMsgb) in
        let retAuthnChallenge = AuthnResponseMsg_returnedAuthnChallenge(authnResponseMsg) in
        let retServerName = AuthnResponseMsg_serverName(authnResponseMsg) in
        let retAssertSignature = AuthnResponseMsg_assertSignature(authnResponseMsg) in

        if (authnChallenge = retAuthnChallenge) && (a = retServerName) then
        if checkSign(retAssertSignature, (retAuthnChallenge, retServerName), userPK) then

        event validChallengeResponse(authnResponseMsgb, encAuthnResponseMsg)
    ).



process
  new tlsKey: Key; (** assume TLS handshake is error-free and yields this symmetric channel-encryption key **)
  new attSecretKey: SKey; (** assume a particular authenticator with a particular attestation private key **)

  let attPublicKey = pk(attSecretKey) in
  (
    !processClientAndAuthnr(tlsKey, attSecretKey, attPublicKey) | !processServer(tlsKey, a)
  )


(** END **)
