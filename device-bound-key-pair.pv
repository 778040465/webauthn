(****** for the proverif model, find "ProVerif Web Authentication Formal Model" below...  ******)


(**** Device-bound Public Key | Device-bound key pair | Device key | Context Key ****


==== WebAuthn Authenticator Response Messages, which include:                       ====
====   Collected Client Data, Attestation Object, and Authenticator Data Structures ====

    // Top-level WebAuthn response messages (in pared-down WebIDL):

    interface AuthenticatorResponse {
        ArrayBuffer      clientDataJSON;     // serialized client data, included in both .create() and .get() responses
    };

    interface AuthenticatorAttestationResponse : AuthenticatorResponse {  // .create() "Registration" response
        ArrayBuffer      attestationObject;  // `attObj` goes here, it contains the `authData` and other components
        [...]
    };

    interface AuthenticatorAssertionResponse : AuthenticatorResponse {    // .get() "Authentication" response
        ArrayBuffer      authenticatorData;  // `authData` goes here
        ArrayBuffer      signature;          // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
        [...] // userHandle
    };



    // Authenticator Data (authData) in RFC5234 ABNF <https://www.w3.org/TR/webauthn/#authenticator-data>:

    authData = rpIdHash flags signCount [attestedCredentialData] [extensions]

        rpIdHash                = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        flags                   = OCTET
        signCount               = 4OCTET    ; 32-bit unsigned big-endian integer

        attestedCredentialData  = AAGUID CredIDLength CredentialID CredentialPublicKey

            AAGUID                  = 16OCTET   ; 16 octets
            CredIDLength            = 2OCTET    ; 16-bit unsigned big-endian integer
            CredentialID            = 16*OCTET  ; CredIDLength octets, at least 16 bytes long
            CredentialPublicKey     = 1*OCTET   ; "user credential": self-describing variable length,
                                                ;  COSE_Key format (CBOR-endoded)

        extensions              = 1*OCTET   ; variable-length CBOR map of extension outputs
                                            ; `devicePublicKey` extension ouput is in here.



    // Attestation Object (attObj) in CDDL <https://www.w3.org/TR/webauthn-2/#sctn-generating-an-attestation-object>

    attObj = {
                authData: bytes,
                $$attStmtType
            }

    attStmtTemplate .within $$attStmtType

    attStmtTemplate = ( ; Every attestation statement format must have these fields:
                          fmt: text,
                          attStmt: { * tstr => any } ; Map is filled in by each concrete attStmtType

                        ; in most formats, the attStmt contains a signature value over:  authData || clientDataHash
                      )


    // `clientDataHash` is the hash of the serialized CollectedClientData object for the current registration
    // or authentication operation (expressed in WebIDL):

        dictionary CollectedClientData {
            required DOMString           type;      // "webauthn.create" or "webauthn.get", as appropriate
            required DOMString           challenge; // from RP's server
            required DOMString           origin;    // https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
            boolean                      crossOrigin;
            // tokenBinding optionally goes here
        }



==== Proposed Collected syntax for devicePublicKey (dpk) Extension Output ====

    $$extensionOutput //= (
        devicePublicKey: AttObjForDevicePublicKey,
    )

    AttObjForDevicePublicKey = { ; Note: This object conveys an attested device public key
                                 ; and is analogous to `attObj`.

        dpkSignatureValue: bstr, ; result of sign(devicePrivateKey, (clientDataHash || userCredentialId))

        authDataForDevicePublicKeyAttestation: AuthDataForDevicePublicKeyAttestation,

        $$attStmtType,      ; see <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object>.
                            ;
                            ; Attestation statement formats define the `fmt` and `attStmt` members of
                            ; $$attStmtType. In summary, it contains a signature value calculated over
                            ; the bytes of _authDataForDevicePublicKeyAttestation_, the attestation
                            ; certificate or public key, and supporting certificates, if any. Note
                            ; that the details are dependent upon the particular attestation statement
                            ; format. See <https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats>.
    }


    AuthDataForDevicePublicKeyAttestation = rpIdHash AAGUID userCredentialIdLength userCredentialId devicePublicKey
                                            ; (expressed in RFC5234 ABNF)

        rpIdHash                  = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        AAGUID                    = 16OCTET   ; 16 octets, authenticator's AAGUID
        userCredentialIdLength    = 2OCTET    ; 2 octets, Credential ID length, 16-bit unsigned big-endian integer
        userCredentialId          = 16*OCTET  ; credentialIdLength octets, at least 16 bytes long
        devicePublicKey           = 1*OCTET   ; self-describing variable length, COSE_Key format (CBOR-endoded)
    ]



==== WebAuthn Signed Objects Hierarchy: Encompassing Attestation Object `attObj` ====

    AuthData for Registration and Authentication Operations returning a devicePublicKey extension response (expressed in RFC5234 ABNF; https://www.w3.org/TR/webauthn/#sctn-authenticator-data ):

        ; See WebAuthn-standard `authData` (above) for details, though NOTE that in these two authData instantiations
        ; `attestedCredentialData` and `extensions` components are always included (the AttObjForDevicePublicKey is conveyed
        ; in the `extensions` component):

        AuthDataForRegistrationReturningDevicePublicKey   = rpIdHash flags signCount attestedCredentialData extensions

        AuthDataForAuthenticationReturningDevicePublicKey = rpIdHash flags signCount extensions


    Registration:
    Encompassing Attestation Object `attObj` (https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object) is returned by the Registration Operation when returning a device-bound public key. This `attObj` attests the user credential, and signs over `AuthDataForRegistrationReturningDevicePublicKey`. The latter object's `extensions` field contains the `devicePublicKey` extension output (see above):

        attObj = {
                    AuthDataForRegistrationReturningDevicePublicKey: bytes,
                    $$attStmtType ; as defined in WebAuthn
                }

    Authentication:







EncompassingRegistrationAttestationToBeSigned: {     // signed by the attestation private key

    AuthDataForRegistrationReturningDevicePublicKey: {

        rpIdHash
        flags
        signCount

        attestedCredentialData: {
            AAGUID
            CredIDLength
            CredentialID        // user credential ID
            CredentialPublicKey // "user credential"
        }

        extensions: {

            devicePublicKeyExtensionResult: {

                dpkSignatureValue { // signed by devicePrivateKey
                    // over...
                    clientDataHash || userCredentialId  // userCredentialId is second because it is variable length
                }

                AuthDataForDevicePublicKeyAttestationToBeSigned: {
                    rpIdHash
                    AAGUID
                    userCredentialIdLength
                    userCredentialId
                    devicePublicKey
                }

                fmt: "...attestation statement format identifier..."

                attStmt: {  // contains various items depending upon the attestation statement format,
                            // crucially containing a signature value, generated using
                            // the device's AttestationPrivatekey, over this to-be-signed data:

                    AuthDataForDevicePublicKeyAttestation   // crucially, this to-be-signed data does not include
                                                            // clientDataHash because the latter is specific to these
                                                            // current request, e.g., the hashed clientData includes
                                                            // the request challenge
                }
            }

            // potentially other extension results...

        } // extensions

    } // AuthDataForRegistrationReturningDevicePublicKey

} // EncompassingRegistrationAttestationToBeSigned



EncompassingAuthenticationAssertionToBeSigned: {     // signed by the user credential private key

    AuthDataForAuthenticationReturningDevicePublicKey: {

        rpIdHash
        flags
        signCount

        // NOTE: there is no `attestedCredentialData` in the authData conveyed in an assertion

        extensions: {

            devicePublicKeyExtensionResult: {

                dpkSignatureValue { // signed by devicePrivateKey..
                    // ..over...
                    clientDataHash || userCredentialId  // userCredentialId is second because it is variable length
                }

                AuthDataForDevicePublicKeyAttestationToBeSigned: {
                    rpIdHash
                    AAGUID                  // where do we get this from if it is not conveyed in authData? Thus must be here.
                    userCredentialIdLength  //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                    userCredentialId        //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                    devicePublicKey         //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                }

                fmt: "...attestation statement format identifier..."

                attStmt: {  // contains various items depending upon the attestation statement format,
                            // crucially containing a signature value, generated using the device's
                            // AttestationPrivatekey, over this to-be-signed data:
                    AuthDataForDevicePublicKeyAttestation
                            // crucially, this to-be-signed data does not include
                            // `clientDataHash` because the latter is specific to this
                            // current request, e.g., the hashed clientData includes
                            // the request challenge.
                }
            }

            // potentially other extension results...

        } // extensions

    } // AuthDataForAuthenticationReturningDevicePublicKey

} // EncompassingAuthenticationAssertionToBeSigned








****)

(* ProVerif Web Authentication Formal Model
   originally by Iness Ben Guirat and Harry Halpin
   https://dl.acm.org/doi/10.1145/3190619.3190640
   github: https://github.com/hhalpin/weauthn-model
*)


free c:channel.

type AttestationPublicKey.
type AttestationPrivatekey.
type nonce.
type pkey.
type skey.
type host.
type key.
type RP_id.


(*For Digital Signatures *)

fun spk(skey):pkey.
fun sign(bitstring, skey):bitstring.
reduc forall x:bitstring, y:skey; getmess(sign(x, y)) = x.
reduc forall x:bitstring, y:skey; checksign(sign(x, y), spk(y)) = x.

(*For nonces*)

fun nonce_to_bitstring ( nonce ) : bitstring [ data , typeConverter ] .
table nonceTable(nonce) .

(*For Digital signature over Attestation Credentials*)

fun spkAtt(AttestationPrivatekey):AttestationPublicKey.
fun signAtt(bitstring, AttestationPrivatekey):bitstring.
reduc forall x:bitstring, y:AttestationPrivatekey; getmessAtt(signAtt(x, y)) = x.
reduc forall x:bitstring, y:AttestationPrivatekey; checksignAtt(signAtt(x, y), spkAtt(y)) = x.

(*Symetric encryption*)

fun senc(bitstring, key): bitstring.
reduc forall x: bitstring, k: key; sdec(senc(x,k),k) = x.


(*User's ID  and Server's ID*)
const cert:bitstring [private].
const a:RP_id [private]. (* server's identity *)
const credentialID2:bitstring [private].

(*Table*)
table tableAtt(AttestationPublicKey).

(*Events and Queries*)

event reachSameKey(AttestationPublicKey).


query N1:AttestationPublicKey; event(reachSameKey(N1)).

free attskU: AttestationPrivatekey[private].
query attacker(attskU).
free attpkU: AttestationPublicKey[private].
query attacker(attpkU).

const k:key. (* TLS record layer symmetric encryption key *)


let processUser ( k: key,cert:bitstring, attskA: AttestationPrivatekey, attpkA:AttestationPublicKey) =

    (*Registration*)

    in(c,s:bitstring); (* server sent

    let(challengeU:nonce, aU:RP_id)= sdec(s,k) in
    new skU:skey;
    let pkU = spk(skU) in

    out(c,senc(signAtt((pkU, attpkU, cert,challengeU), attskU),k))
    .


let processServer (k: key, a:RP_id) =

    (*Registration*)

    new challenge: nonce;

    out(c, senc( (challenge, a), k) ); (* send challenge & RP_id over TLS *)

    in(c, s:bitstring);

    let m= sdec(s,k) in
    let (pkY1: pkey, attpkU1:AttestationPublicKey, cert: bitstring, Nt:nonce) = getmessAtt(m) in
    let ver = checksignAtt(m, attpkU1) in

   get tableAtt(= attpkU1) in event reachSameKey(attpkU1)
   else insert tableAtt(attpkU1).

process
  new attskU:AttestationPrivatekey;
  let attpkU = spkAtt(attskU) in
  (
    !processUser( k, cert, attskU,attpkU) | !processServer(k, a)
  )

