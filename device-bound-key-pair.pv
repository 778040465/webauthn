(****** for the proverif model, find "ProVerif Web Authentication Formal Model" below...  ******)


(**** Device-bound Public Key | Device-bound Key Pair | Device key | Context Key | Secondary Key ****


==== WebAuthn Authenticator Response Messages, which include:                       ====
====   Collected Client Data, Attestation Object, Authenticator Data structures,    ====
====   and (nested) signature values calculated over portions of them.              ====

    // Top-level WebAuthn response messages (expressed in simplified WebIDL):

    interface AuthenticatorResponse {
        ArrayBuffer      clientDataJSON;    // serialized collected client data, included
                                            // in both .create() and .get() responses
    };

    interface AuthenticatorAttestationResponse : AuthenticatorResponse {  // .create() "Registration" response
        ArrayBuffer      attestationObject;  // `attObj` goes here, it contains the `authData` and other components
        [...]
    };

    interface AuthenticatorAssertionResponse : AuthenticatorResponse {    // .get() "Authentication" response
        ArrayBuffer      authenticatorData;  // `authData` goes here
        ArrayBuffer      signature;          // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
                                             // Note that the signed-over authData conveys extension results
        [...] // userHandle
    };



    // Authenticator Data (authData) in RFC5234 ABNF <https://www.w3.org/TR/webauthn/#authenticator-data>:

    authData = rpIdHash flags signCount [attestedCredentialData] [extensions]

        rpIdHash                = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        flags                   = OCTET
        signCount               = 4OCTET    ; 32-bit unsigned big-endian integer

        attestedCredentialData  = AAGUID CredIDLength CredentialID CredentialPublicKey

            AAGUID                  = 16OCTET   ; 16 octets
            CredIDLength            = 2OCTET    ; 16-bit unsigned big-endian integer
            CredentialID            = 16*OCTET  ; CredIDLength octets, at least 16 bytes long
            CredentialPublicKey     = 1*OCTET   ; "user credential": self-describing variable length,
                                                ;  COSE_Key format (CBOR-endoded)

        extensions              = 1*OCTET   ; variable-length CBOR map of extension outputs
                                            ; `devicePublicKey` extension ouput is in here.



    // Attestation Object (attObj) in CDDL <https://www.w3.org/TR/webauthn-2/#sctn-generating-an-attestation-object>

    attObj = {
                authData: bytes,
                $$attStmtType
            }

    attStmtTemplate .within $$attStmtType

    attStmtTemplate = ( ; Every attestation statement format must have these fields:
                          fmt: text,
                          attStmt: { * tstr => any } ; Map is filled in by each concrete attStmtType

                        ; in most formats, the attStmt contains a signature value over:  authData || clientDataHash
                      )


    // `clientDataHash` is the hash of the serialized CollectedClientData object for the current registration
    // or authentication operation (expressed in WebIDL):

        dictionary CollectedClientData {
            required DOMString           type;      // "webauthn.create" or "webauthn.get", as appropriate
            required DOMString           challenge; // from RP's server
            required DOMString           origin;    // https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
            boolean                      crossOrigin;
            // tokenBinding optionally goes here
        }



==== Proposed Collected Syntax for devicePublicKey (dpk) aka Secondary Key aka Device Key Extension Output ====

    $$extensionOutput //= (                         // Expressed in CDDL
        devicePublicKey: AttObjForDevicePublicKey,
    )

    AttObjForDevicePublicKey = { ; Note: This object conveys an attested device public key
                                 ; and is analogous to `attObj`.

        dpkSignatureValue: bstr, ; result of sign(devicePrivateKey, (clientDataHash || userCredentialId))

        authDataForDevicePublicKeyAttestation: bstr,    ; AuthDataForDevicePublicKeyAttestation goes here

        $$attStmtType,      ; see <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object>.
                            ;
                            ; Attestation statement formats define the `fmt` and `attStmt` members of
                            ; $$attStmtType.
                            ;
                            ; In summary, it contains a signature value calculated over
                            ; the bytes of `authDataForDevicePublicKeyAttestation`, the attestation
                            ; certificate or public key, and supporting certificates, if any. Note
                            ; that the details are dependent upon the particular attestation statement
                            ; format. See <https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats>.
    }


    AuthDataForDevicePublicKeyAttestation = rpIdHash AAGUID userCredentialIdLength userCredentialId devicePublicKey
                                            ; Expressed in RFC5234 ABNF

        rpIdHash                  = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        AAGUID                    = 16OCTET   ; 16 octets, authenticator's AAGUID
        userCredentialIdLength    = 2OCTET    ; 2 octets, Credential ID length, 16-bit unsigned big-endian integer
        userCredentialId          = 16*OCTET  ; credentialIdLength octets, at least 16 bytes long
        devicePublicKey           = 1*OCTET   ; self-describing variable length, COSE_Key format (CBOR-endoded)




==== WebAuthn Signed Objects Hierarchy for Device-bound Key Pair aka Device-bound Public Key aka Secondary Key aka Device Key ====

    AuthData for Registration and Authentication Operations returning a devicePublicKey extension response (expressed in RFC5234 ABNF; https://www.w3.org/TR/webauthn/#sctn-authenticator-data ):

        ; See WebAuthn-standard `authData` (above) for details, though NOTE that in these two `authData` instantiations
        ; the `extensions` component is ALWAYS included because the `AttObjForDevicePublicKey` is always conveyed
        ; in the `extensions` component:

        AuthDataForRegistrationReturningDevicePublicKey   = rpIdHash flags signCount attestedCredentialData extensions

        AuthDataForAuthenticationReturningDevicePublicKey = rpIdHash flags signCount extensions


    Registration:

    Encompassing Attestation Object `attObj` <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object> is returned by the Registration Operation (in `AuthenticatorAttestationResponse.attestationObject`). This `attObj` attests the user credential, and signs over `AuthDataForRegistrationReturningDevicePublicKey`. The latter object's `extensions` field contains the `devicePublicKey` extension output (see above):

        AuthenticatorAttestationResponse: {
            clientDataJSON
            attestationObject
        }

        attObj = {
                    AuthDataForRegistrationReturningDevicePublicKey: bytes, ; devicePublicKey extension result is here
                    $$attStmtType   ; as defined in WebAuthn, contains ENCOMPASSING SIGNATURE VALUE over:
                                    ;
                }


    Authentication:

    Encompassing Authentication Assertion is returned by the Authentication Operation (as `AuthenticatorAssertionResponse`). The "assertion" is the `signature` value over the concatenation of the `AuthDataForAuthenticationReturningDevicePublicKey` and the hash of the collected client data containing the RP's challenge. `AuthDataForAuthenticationReturningDevicePublicKey`'s `extensions` field contains the `devicePublicKey` extension output:

        AuthenticatorAssertionResponse: {
            clientDataJSON
            AuthDataForAuthenticationReturningDevicePublicKey
            signature       // ENCOMPASSING SIGNATURE VALUE over:
                            //   AuthDataForAuthenticationReturningDevicePublicKey || clientDataHash
        }




    EncompassingRegistrationAttestationToBeSigned: {     // SIGNED by the attestation private key

        AuthDataForRegistrationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            attestedCredentialData: {
                AAGUID
                CredIDLength
                CredentialID        // user credential ID
                CredentialPublicKey // "user credential"
            }

            extensions: {

                devicePublicKeyExtensionResult: {

                    dpkSignatureValue { // SIGNED by devicePrivateKey. Is a UNIQUE value per response.
                        // over...
                        clientDataHash || userCredentialId  // userCredentialId is second because it is variable length
                    }

                    AuthDataForDevicePublicKeyAttestationToBeSigned: {
                        rpIdHash
                        AAGUID
                        userCredentialIdLength
                        userCredentialId
                        devicePublicKey
                    }

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // contains various items depending upon the attestation statement format,
                                // crucially containing a signature value, generated using
                                // the device's AttestationPrivatekey, over this to-be-signed data:

                        AuthDataForDevicePublicKeyAttestation   // crucially, this to-be-signed data does not include
                                                                // clientDataHash because the latter is specific to these
                                                                // current request, e.g., the hashed clientData includes
                                                                // the request challenge.
                                                                //
                                                                // The `attStmt` is a CONSTANT value per context per device
                                                                // per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForRegistrationReturningDevicePublicKey

    } // EncompassingRegistrationAttestationToBeSigned



    EncompassingAuthenticationAssertionToBeSigned: {     // SIGNED by the user credential private key

        AuthDataForAuthenticationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            // NOTE: there is no `attestedCredentialData` in the authData conveyed in an assertion

            extensions: {

                devicePublicKeyExtensionResult: {

                    dpkSignatureValue { // SIGNED by devicePrivateKey..
                        // ..over...
                        clientDataHash || userCredentialId  // userCredentialId is second because it is variable length
                    }

                    AuthDataForDevicePublicKeyAttestationToBeSigned: {
                        rpIdHash                // i.e., the "audience"
                        AAGUID                  // where do we get this from if it is not conveyed in authData? Thus must be here.
                        userCredentialIdLength  //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                        userCredentialId        //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                        devicePublicKey         //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                    }

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // contains various items depending upon the attestation statement format,
                                // crucially containing a signature value, generated using the device's
                                // AttestationPrivatekey, over this to-be-signed data:
                        AuthDataForDevicePublicKeyAttestation
                                //
                                // Crucially, this to-be-signed data DOES NOT INCLUDE
                                // `clientDataHash` because the latter is specific to this
                                // current request, e.g., the hashed clientData includes
                                // the request challenge.
                                //
                                // NOTE: The `attStmt` is a CONSTANT value per context per device
                                // per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForAuthenticationReturningDevicePublicKey

    } // EncompassingAuthenticationAssertionToBeSigned



****)

(* ProVerif Web Authentication Formal Model
   originally by Iness Ben Guirat and Harry Halpin
   https://dl.acm.org/doi/10.1145/3190619.3190640
   github: https://github.com/hhalpin/weauthn-model
*)

type AttestationPublicKey.
type AttestationPrivatekey.
type nonce.
type pkey.
type skey.
type key.
type RP_id.

(* TLS channel *)

free c: channel. (* TLS channel *)

const k: key. (* TLS record layer symmetric encryption key.
                 This model assumes an error-free TLS connection establishment
                 resulting in this key |k| as the encryption key. *)


(* For Digital Signatures *)

fun spk(skey): pkey.
fun sign(bitstring, skey): bitstring.
reduc forall x:bitstring, y:skey; getmess(sign(x, y)) = x.
reduc forall x:bitstring, y:skey; checksign(sign(x, y), spk(y)) = x.

(* For nonces *)

fun nonce_to_bitstring ( nonce ) : bitstring [ data , typeConverter ] .
table nonceTable(nonce) .

(* For Digital signature over Attestation Credentials *)

fun spkAtt(AttestationPrivatekey):AttestationPublicKey.
fun signAtt(bitstring, AttestationPrivatekey):bitstring.
reduc forall x:bitstring, y:AttestationPrivatekey; getmessAtt(signAtt(x, y)) = x.
reduc forall x:bitstring, y:AttestationPrivatekey; checksignAtt(signAtt(x, y), spkAtt(y)) = x.

(* Symetric encryption *)

fun senc(bitstring, key): bitstring.
reduc forall x: bitstring, k: key; sdec(senc(x,k),k) = x.


(* User's ID  and Server's ID *)
const cert:bitstring [private].
const a: RP_id [private]. (* server's identity *)

(* Table *)
table tableAtt(AttestationPublicKey).

(* Events and Queries *)

event reachSameKey(AttestationPublicKey).

query N1:AttestationPublicKey; event(reachSameKey(N1)).

free attskU: AttestationPrivatekey [private].
query attacker(attskU).

free attpkU: AttestationPublicKey [private].
query attacker(attpkU).


let processUser (k: key, cert: bitstring, attskA: AttestationPrivatekey, attpkA: AttestationPublicKey) =

    (*Registration*)

    in(c, s: bitstring); (* we expect server to send challenge & RP_id over encrypted TLS channel *)

    let (challengeU: nonce, aU: RP_id) = sdec(s, k) in

    new skU: skey;          (* user's authenticator mints new user credential key pair *)
    let pkU = spk(skU) in

    out(c, senc(signAtt((pkU, attpkU, cert, challengeU), attskU), k)). (* return signed registration response
                                                                          containing attestation object, over
                                                                          encrypted TLS channel. *)


let processServer (k: key, a:RP_id) =

    (*Registration*)

    new challenge: nonce;

    out(c, senc((challenge, a), k)); (* Reg request: send challenge & RP_id over TLS *)

    in(c, s:bitstring);              (* Registration response *)

    let m = sdec(s, k) in
    let (pkY1: pkey, attpkU1: AttestationPublicKey, cert: bitstring, Nt: nonce) = getmessAtt(m) in
    let ver = checksignAtt(m, attpkU1) in  (* This verifies the attestation signature because `getmess()` does not. *)

    get tableAtt(=attpkU1) in       (* Have we seen this registration before? *)
        event reachSameKey(attpkU1) (* Yes.                                   *)
    else
        insert tableAtt(attpkU1).   (* No, remember it.                       *)

process
  new attskU: AttestationPrivatekey;    (* The attestation key pair is a immutable property of     *)
  let attpkU = spkAtt(attskU) in        (* the authenticator, so we mint it here at the beginning. *)
  (
    !processUser(k, cert, attskU, attpkU) | !processServer(k, a)
  )

