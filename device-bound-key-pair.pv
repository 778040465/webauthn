(****** for the proverif model, find "ProVerif Web Authentication Formal Model" below...  ******)


(**** Device-bound Public Key | Device-bound Key Pair | Device key | Context Key | Secondary Key ****


==== WebAuthn Authenticator Response Messages, which include:                       ====
====   Collected Client Data, Attestation Object, Authenticator Data structures,    ====
====   and (nested) signature values calculated over portions of them.              ====

    // Top-level WebAuthn response messages (expressed in simplified WebIDL):

    interface PublicKeyCredential : Credential {
        USVString               id;        // User Credential ID
        AuthenticatorResponse   response;
        [...]
    };

    interface AuthenticatorResponse {
        ArrayBuffer      clientDataJSON;    // serialized collected client data, included
                                            // in both .create() and .get() responses
    };

    interface AuthenticatorAttestationResponse : AuthenticatorResponse {  // .create() "Registration" response
        ArrayBuffer      attestationObject;  // `attObj` goes here, it contains the `authData` and other components
        [...]
    };

    interface AuthenticatorAssertionResponse : AuthenticatorResponse {    // .get() "Authentication" response
        ArrayBuffer      authenticatorData;  // `authData` goes here
        ArrayBuffer      signature;          // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
                                             // Note that the signed-over authData conveys extension results
        [...] // userHandle
    };



    Coalesced Registration PublicKeyCredential: {
        USVString       id;                  // User Credential ID
        ArrayBuffer     clientDataJSON;
        ArrayBuffer     attestationObject;   // `attObj` goes here, it contains the `authData` and other component
    }


    Coalesced Authentication PublicKeyCredential: {
        USVString       id;                  // User Credential ID
        ArrayBuffer     clientDataJSON;
        ArrayBuffer     authenticatorData;   // `authData` goes here
        ArrayBuffer     signature;           // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
                                             // Note that the signed-over authData conveys extension results
        [...]
    }



    // Authenticator Data (authData) in RFC5234 ABNF <https://www.w3.org/TR/webauthn/#authenticator-data>:

    authData = rpIdHash flags signCount [attestedCredentialData] [extensions]

        rpIdHash                = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        flags                   = OCTET
        signCount               = 4OCTET    ; 32-bit unsigned big-endian integer

        attestedCredentialData  = AAGUID CredIDLength CredentialID CredentialPublicKey

            AAGUID                  = 16OCTET   ; 16 octets
            CredIDLength            = 2OCTET    ; 16-bit unsigned big-endian integer
            CredentialID            = 16*OCTET  ; CredIDLength octets, at least 16 bytes long
            CredentialPublicKey     = 1*OCTET   ; "user credential": self-describing variable length,
                                                ;  COSE_Key format (CBOR-endoded)

        extensions              = 1*OCTET   ; variable-length CBOR map of extension outputs
                                            ; `devicePublicKey` extension ouput is in here.



    // Attestation Object (attObj) in CDDL <https://www.w3.org/TR/webauthn-2/#sctn-generating-an-attestation-object>

    attObj = {
                authData: bytes,
                $$attStmtType
            }

    attStmtTemplate .within $$attStmtType

    attStmtTemplate = ( ; Every attestation statement format must have these fields:
                          fmt: text,
                          attStmt: { * tstr => any } ; Map is filled in by each concrete attStmtType

                        ; in most formats, the attStmt contains a signature value over:  authData || clientDataHash
                      )


    // `clientDataHash` is the hash of the serialized CollectedClientData object for the current registration
    // or authentication operation (expressed in WebIDL):

        dictionary CollectedClientData {
            required DOMString           type;      // "webauthn.create" or "webauthn.get", as appropriate
            required DOMString           challenge; // from RP's server
            required DOMString           origin;    // https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
            boolean                      crossOrigin;
            // tokenBinding optionally goes here
        }



==== Proposed Collected Syntax for devicePublicKey (dpk) (aka Secondary Key aka Device Key) Extension Output ====

    $$extensionOutput //= (                         // Expressed in CDDL
        devicePublicKey: AttObjForDevicePublicKey,
    )

    AttObjForDevicePublicKey = { ; Note: This object conveys an attested device public key
                                 ; and is analogous to `attObj`.

        dpkSignatureValue: bstr, ; result of sign(devicePrivateKey, (clientDataHash || userCredentialId))
                                 ; Note that this sig value is unique per-request because clientDataHash contains
                                 ; the per-request challenge.

        authDataForDevicePublicKeyAttestation: bstr,    ; AuthDataForDevicePublicKeyAttestation goes here

        $$attStmtType,      ; see <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object>.
                            ;
                            ; Attestation statement formats define the `fmt` and `attStmt` members of
                            ; $$attStmtType.
                            ;
                            ; In summary, it contains (1) a signature value calculated (using the attestation private key)
                            ; over just the bytes of `authDataForDevicePublicKeyAttestation`, and (2) the attestation
                            ; certificate or public key, and supporting certificates, if any. Note
                            ; that there are details dependent upon the particular attestation statement
                            ; format. See <https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats>.
    }


    AuthDataForDevicePublicKeyAttestation = rpIdHash AAGUID userCredentialIdLength userCredentialId devicePublicKey
                                            ; Expressed in RFC5234 ABNF:

        rpIdHash                  = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        AAGUID                    = 16OCTET   ; 16 octets, authenticator's AAGUID
        userCredentialIdLength    = 2OCTET    ; 2 octets, Credential ID length, 16-bit unsigned big-endian integer
        userCredentialId          = 16*OCTET  ; credentialIdLength octets, at least 16 bytes long
        devicePublicKey           = 1*OCTET   ; self-describing variable length, COSE_Key format (CBOR-endoded)




==== WebAuthn Signed Objects Hierarchy for Device-bound Key Pair aka Device-bound Public Key aka Secondary Key aka Device Key ====

    AuthData for Registration and Authentication Operations returning a devicePublicKey extension response (expressed in RFC5234 ABNF; https://www.w3.org/TR/webauthn/#sctn-authenticator-data ):

        ; See WebAuthn-standard `authData` (above) for details, though NOTE that in these two `authData` instantiations
        ; the `extensions` component is ALWAYS included because the `AttObjForDevicePublicKey` is always conveyed
        ; in the `extensions` component:

        AuthDataForRegistrationReturningDevicePublicKey   = rpIdHash flags signCount attestedCredentialData extensions

        AuthDataForAuthenticationReturningDevicePublicKey = rpIdHash flags signCount extensions


    Registration:

    Encompassing Attestation Object `attObj` <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object> is returned by the Registration Operation (in `AuthenticatorAttestationResponse.attestationObject`). This `attObj` attests the user credential, and signs over `AuthDataForRegistrationReturningDevicePublicKey`. The latter object's `extensions` field contains the `devicePublicKey` extension output (see above):

        AuthenticatorAttestationResponse: {
            clientDataJSON
            attestationObject
        }

        attObj = {
                    AuthDataForRegistrationReturningDevicePublicKey: bytes, ; devicePublicKey extension result is here
                    $$attStmtType   ; as defined in WebAuthn, contains ENCOMPASSING SIGNATURE VALUE over:
                                    ;
                }


    Authentication:

    Encompassing Authentication Assertion is returned by the Authentication Operation (as `AuthenticatorAssertionResponse`). The "assertion" is the `signature` value over the concatenation of the `AuthDataForAuthenticationReturningDevicePublicKey` and the hash of the collected client data containing the RP's challenge. `AuthDataForAuthenticationReturningDevicePublicKey`'s `extensions` field contains the `devicePublicKey` extension output:

        AuthenticatorAssertionResponse: {  // expressed in bespoke informal notation
            clientDataJSON
            AuthDataForAuthenticationReturningDevicePublicKey
            signature       // ENCOMPASSING SIGNATURE VALUE over:
                            //   AuthDataForAuthenticationReturningDevicePublicKey || clientDataHash
        }


    ==== To-Be-Signed Data for the ENCOMPASSING SIGNATURE VALUEs (expressed in bespoke informal notation):

    EncompassingRegistrationAttestationToBeSigned: {    // SIGNED by the attestation private key to form the signature
                                                        // value returned in the top-level attestation statement.

        AuthDataForRegistrationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            attestedCredentialData: {
                AAGUID
                CredIDLength
                CredentialID        // user credential ID
                CredentialPublicKey // "user credential"
            }

            extensions: {

                devicePublicKeyExtensionResult: {

                    dpkSignatureValue { // Is a UNIQUE value per response.
                        sign(devicePrivateKey, (clientDataHash || userCredentialId))
                    }

                    AuthDataForDevicePublicKeyAttestation: {
                        rpIdHash                // i.e., the "audience"
                        AAGUID                  // This, and the next 3 data items, duplicate what's in
                        userCredentialIdLength  // `attestedCredentialData`, but attested cred data is not present in
                        userCredentialId        // authentication assertions, so it needs to be here IF we wish this
                        devicePublicKey         // devicePublicKey extension result to be the same format whether its
                                                // returned as result of a registration or authn request.
                    }

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // contains various items depending upon the attestation statement format,
                                // Crucially containing a signature value, generated using
                                // the device's (effective) AttestationPrivatekey, over this to-be-signed data:

                        AuthDataForDevicePublicKeyAttestation   // SIGNED by AttestationPrivatekey.
                                                                // Crucially, this to-be-signed data does not include
                                                                // clientDataHash because the latter is specific to these
                                                                // current request, e.g., the hashed clientData includes
                                                                // the request challenge.
                                                                //
                                                                // Note: This `attStmt` is a CONSTANT value per context
                                                                // per device per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForRegistrationReturningDevicePublicKey

        ClientDataHash: {  // the following items are serialized then hashed to form this value:
            type
            challenge
            origin
            crossOrigin
        }

    } // EncompassingRegistrationAttestationToBeSigned



    EncompassingAuthenticationAssertionToBeSigned: {    // SIGNED by the user credential private key yielding the
                                                        // `AuthenticatorAssertionResponse.signature` value.

        AuthDataForAuthenticationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            // NOTE: there is no `attestedCredentialData` in the authData conveyed in an assertion

            extensions: {

                devicePublicKeyExtensionResult: {

                    dpkSignatureValue { // SIGNED by devicePrivateKey..
                        // ..over...
                        clientDataHash || userCredentialId  // userCredentialId is second because it is variable length
                    }

                    AuthDataForDevicePublicKeyAttestationToBeSigned: {
                        rpIdHash               // i.e., the "audience"
                        AAGUID                 // where do we get this from if it is not conveyed in authData? Thus must be here?
                        userCredentialIdLength //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                        userCredentialId       //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                        devicePublicKey        //   "   "  "   "   "    "   "  "  "   "      "    "     "        "   "   "   "
                    }

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // Contains various items depending upon the attestation statement format,
                                // crucially containing a signature value, generated using the device's (effective)
                                // AttestationPrivatekey, over this to-be-signed data:
                        AuthDataForDevicePublicKeyAttestation
                                //
                                // Crucially, this to-be-signed data DOES NOT INCLUDE
                                // `clientDataHash` because the latter is specific to this
                                // current request, e.g., the hashed clientData includes
                                // the request challenge.
                                //
                                // NOTE: This `attStmt` is a CONSTANT value per context per device
                                // per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForAuthenticationReturningDevicePublicKey

        ClientDataHash: {  // the following items are serialized then hashed to form this value:
            type
            challenge
            origin
            crossOrigin
        }

    } // EncompassingAuthenticationAssertionToBeSigned



****)

(* ProVerif Web Authentication Formal Model
   originally by Iness Ben Guirat and Harry Halpin
   Paper: https://dl.acm.org/doi/10.1145/3190619.3190640
   github: https://github.com/hhalpin/weauthn-model [sic]
*)

(**** unlinkability.pv ****

This model simply proves that if the same authenticator is used to authenticate with a given server in the context of different accounts, the server can correlate the authenticator use across those accounts because the attestation public key is the same. See

To counter this, it is advised by the FIDO Alliance (fidoalliance.org) that authenticators use the same attestation key pair for large batches (100K) of authenticators.

This version editorially cleaned up, as well as technically: removed unused types, variables, etc.
****)

type AttestationPublicKey.
type AttestationPrivatekey.
type nonce.
type pkey.
type skey.
type key.
type RP_id.

(* TLS channel *)

free c: channel. (* TLS channel *)

const k: key. (* TLS record layer symmetric encryption key.
                 This model assumes an error-free TLS connection establishment
                 resulting in this key |k| as the encryption key. *)


(* For Digital Signatures *)

fun spk(skey): pkey.
fun sign(bitstring, skey): bitstring.
reduc forall x:bitstring, y:skey; getmess(sign(x, y)) = x.
reduc forall x:bitstring, y:skey; checksign(sign(x, y), spk(y)) = x.

(* For nonces *)

fun nonce_to_bitstring ( nonce ) : bitstring [ data , typeConverter ] .
table nonceTable(nonce) .

(* For Digital signature over Attestation Credentials *)

fun spkAtt(AttestationPrivatekey):AttestationPublicKey.
fun signAtt(bitstring, AttestationPrivatekey):bitstring.
reduc forall x:bitstring, y:AttestationPrivatekey; getmessAtt(signAtt(x, y)) = x.
reduc forall x:bitstring, y:AttestationPrivatekey; checksignAtt(signAtt(x, y), spkAtt(y)) = x.

(* Symetric encryption *)

fun senc(bitstring, key): bitstring.
reduc forall x: bitstring, k: key; sdec(senc(x,k),k) = x.


(* Server's ID *)
const a: RP_id [private]. (* server's identity *)

(* Table *)
table tableAtt(AttestationPublicKey).

(* Events and Queries *)

event reachSameKey(AttestationPublicKey).

query N1:AttestationPublicKey; event(reachSameKey(N1)).

free attskU: AttestationPrivatekey [private].
query attacker(attskU).

free attpkU: AttestationPublicKey [private].
query attacker(attpkU).


let processUser (k: key, attskA: AttestationPrivatekey, attpkA: AttestationPublicKey) =

    (*Registration*)

    in(c, s: bitstring); (* we expect server to send challenge & RP_id over encrypted TLS channel *)

    let (challengeU: nonce, aU: RP_id) = sdec(s, k) in

    new skU: skey;          (* user's authenticator mints new user credential key pair *)
    let pkU = spk(skU) in

    out(c, senc(signAtt((pkU, attpkU, challengeU), attskU), k)). (* return signed registration response
                                                                          containing attestation object, over
                                                                          encrypted TLS channel. *)


let processServer (k: key, a:RP_id) =

    (*Registration*)

    new challenge: nonce;

    out(c, senc((challenge, a), k)); (* Reg request: send challenge & RP_id over TLS *)

    in(c, s:bitstring);              (* Registration response *)

    let m = sdec(s, k) in
    let (pkY1: pkey, attpkU1: AttestationPublicKey, Nt: nonce) = getmessAtt(m) in
    let ver = checksignAtt(m, attpkU1) in  (* This verifies the attestation signature because `getmess()` does not. *)

    get tableAtt(=attpkU1) in       (* Have we seen this registration before? *)
        event reachSameKey(attpkU1) (* Yes, thus the user is re-identified,   *)
                                    (* modulo the authenticator batch size    *)
                                    (* having the same attestation key pair.  *)
    else
        insert tableAtt(attpkU1).   (* No, remember it.                       *)

process
  new attskU: AttestationPrivatekey;    (* The attestation key pair is a immutable property of     *)
  let attpkU = spkAtt(attskU) in        (* the authenticator, so we mint it here at the beginning. *)
  (
    !processUser(k, attskU, attpkU) | !processServer(k, a)
  )

(* END *)

