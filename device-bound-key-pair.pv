(****** for the proverif model, find "ProVerif Web Authentication Formal Model" below...  ******)


(**** Device-bound Public Key | Device-bound Key Pair | Device key | Context Key | Secondary Key ****


==== WebAuthn Authenticator Response Messages, which include:                       ====
====   Collected Client Data, Attestation Object, Authenticator Data structures,    ====
====   and (nested) signature values calculated over portions of them.              ====

    // Top-level WebAuthn response messages (expressed in simplified WebIDL):

    interface PublicKeyCredential : Credential {
        USVString               id;        // User Credential ID
        AuthenticatorResponse   response;
        [...]
    };

    interface AuthenticatorResponse {
        ArrayBuffer      clientDataJSON;    // serialized collected client data, included
                                            // in both .create() and .get() responses
    };

    interface AuthenticatorAttestationResponse : AuthenticatorResponse {  // .create() "Registration" response
        ArrayBuffer      attestationObject;  // `attObj` goes here, it contains the `authData` and other components
        [...]
    };

    interface AuthenticatorAssertionResponse : AuthenticatorResponse {    // .get() "Authentication" response
        ArrayBuffer      authenticatorData;  // `authData` goes here
        ArrayBuffer      signature;          // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
                                             // Note that the signed-over authData conveys extension results
        [...] // userHandle
    };



    Coalesced Registration PublicKeyCredential: {
        USVString       id;                  // User Credential ID
        ArrayBuffer     clientDataJSON;
        ArrayBuffer     attestationObject;   // `attObj` goes here, it contains the `authData` and other component
    }


    Coalesced Authentication PublicKeyCredential: {
        USVString       id;                  // User Credential ID
        ArrayBuffer     clientDataJSON;
        ArrayBuffer     authenticatorData;   // `authData` goes here
        ArrayBuffer     signature;           // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
                                             // Note that the signed-over authData conveys extension results
        [...]
    }



    // Authenticator Data (authData) in RFC5234 ABNF <https://www.w3.org/TR/webauthn/#authenticator-data>:

    authData = rpIdHash flags signCount [attestedCredentialData] [extensions]

        rpIdHash                = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        flags                   = OCTET
        signCount               = 4OCTET    ; 32-bit unsigned big-endian integer

        attestedCredentialData  = AAGUID CredIDLength CredentialID CredentialPublicKey

            AAGUID                  = 16OCTET   ; 16 octets
            CredIDLength            = 2OCTET    ; 16-bit unsigned big-endian integer
            CredentialID            = 16*OCTET  ; CredIDLength octets, at least 16 octets long
            CredentialPublicKey     = 1*OCTET   ; "user credential": self-describing variable length,
                                                ;  COSE_Key format (CBOR-endoded)

        extensions              = 1*OCTET   ; variable-length CBOR map of extension outputs
                                            ; `devicePublicKey` extension ouput is in here.



    // Attestation Object (attObj) in CDDL <https://www.w3.org/TR/webauthn-2/#sctn-generating-an-attestation-object>

    attObj = {
                authData: bytes,
                $$attStmtType
            }

    attStmtTemplate .within $$attStmtType

    attStmtTemplate = ( ; Every attestation statement format must have these fields:
                          fmt: text,
                          attStmt: { * tstr => any } ; Map is filled in by each concrete attStmtType

                        ; in most formats, the attStmt contains a signature value of:
                        ;   sign (authData || clientDataHash
                      )


    // `clientDataHash` is the hash of the serialized CollectedClientData object for the current registration
    // or authentication operation (expressed in WebIDL):

        dictionary CollectedClientData {
            required DOMString           type;      // "webauthn.create" or "webauthn.get", as appropriate
            required DOMString           challenge; // from RP's server
            required DOMString           origin;    // https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
            boolean                      crossOrigin;
            // tokenBinding optionally goes here
        }



==== Proposed Collected Syntax for devicePublicKey (dpk) (aka Secondary Key aka Device Key) Extension Output ====

    $$extensionOutput //= (                         // Expressed in CDDL
        devicePublicKey: AttObjForDevicePublicKey,
    )

    AttObjForDevicePublicKey = { ; Note: This object conveys an attested device public key
                                 ; and is analogous to `attObj`.

        dpkSignatureValue: bstr, ; result of sign(devicePrivateKey, (clientDataHash || userCredentialId))
                                 ; Note that this sig value changes per-request because clientDataHash contains
                                 ; the per-request challenge.

        authDataForDevicePublicKeyAttestation: bstr,    ; AuthDataForDevicePublicKeyAttestation goes here

        $$attStmtType,      ; see <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object>.
                            ;
                            ; Attestation statement formats define the `fmt` and `attStmt` members of
                            ; $$attStmtType.
                            ;
                            ; In summary, it contains (1) a signature value calculated (using the attestation private key)
                            ; over just the bytes of `authDataForDevicePublicKeyAttestation`, and (2) the attestation
                            ; certificate or public key, and supporting certificates, if any. Note
                            ; that there are details dependent upon the particular attestation statement
                            ; format. See <https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats>.
    }


    AuthDataForDevicePublicKeyAttestation = rpIdHash AAGUID userCredentialIdLength userCredentialId devicePublicKey
                                            ; Expressed in RFC5234 ABNF:

        rpIdHash                  = 32OCTET   ; SHA-256 hash of the RP ID the device key pair is scoped to
        AAGUID                    = 16OCTET   ; authenticator's AAGUID
        devicePublicKey           = 1*OCTET   ; self-describing variable length, COSE_Key format (CBOR-endoded)




==== WebAuthn Signed Objects Hierarchy for Device-bound Key Pair aka Device-bound Public Key aka Secondary Key aka Device Key ====

    AuthData for Registration and Authentication Operations returning a devicePublicKey extension response (expressed in RFC5234 ABNF; https://www.w3.org/TR/webauthn/#sctn-authenticator-data ):

        ; See WebAuthn-standard `authData` (above) for details, though NOTE that in these two `authData` instantiations
        ; the `extensions` component is ALWAYS included because the `AttObjForDevicePublicKey` is always conveyed
        ; in the `extensions` component:

        AuthDataForRegistrationReturningDevicePublicKey   = rpIdHash flags signCount attestedCredentialData extensions

        AuthDataForAuthenticationReturningDevicePublicKey = rpIdHash flags signCount extensions


    Registration:

    Encompassing Attestation Object `attObj` <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object> is returned by the Registration Operation (in `AuthenticatorAttestationResponse.attestationObject`). This `attObj` attests the user credential, and signs over `AuthDataForRegistrationReturningDevicePublicKey`. The latter object's `extensions` field contains the `devicePublicKey` extension output (see above):

        AuthenticatorAttestationResponse: {
            clientDataJSON
            attestationObject
        }

        attObj = {
                    AuthDataForRegistrationReturningDevicePublicKey: bytes, ; devicePublicKey extension result is here
                    $$attStmtType   ; as defined in WebAuthn, contains ENCOMPASSING SIGNATURE VALUE over:
                                    ;
                }


    Authentication:

    Encompassing Authentication Assertion is returned by the Authentication Operation (as `AuthenticatorAssertionResponse`). The "assertion" is the `signature` value over the concatenation of the `AuthDataForAuthenticationReturningDevicePublicKey` and the hash of the collected client data containing the RP's challenge. `AuthDataForAuthenticationReturningDevicePublicKey`'s `extensions` field contains the `devicePublicKey` extension output:

        AuthenticatorAssertionResponse: {  // expressed in bespoke informal notation
            clientDataJSON
            AuthDataForAuthenticationReturningDevicePublicKey
            signature       // ENCOMPASSING SIGNATURE VALUE over:
                            //   AuthDataForAuthenticationReturningDevicePublicKey || clientDataHash
        }


    ==== To-Be-Signed Data for the ENCOMPASSING SIGNATURE VALUEs (expressed in bespoke informal notation):

    EncompassingRegistrationAttestationToBeSigned: {    // SIGNED by the attestation private key to form the signature
                                                        // value returned in the top-level attestation statement.
                                                        // This is only depicting what gets signed by which signing key,
                                                        // NOTE that the e.g. credentialID is conveyed unsigned in the
                                                        // PublicKeyCredential object.

        AuthDataForRegistrationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            attestedCredentialData: {
                AAGUID
                CredIDLength
                CredentialID        // user credential ID
                CredentialPublicKey // "user credential"
            }

            extensions: {

                devicePublicKeyExtensionResult: {

                    dpkSignatureValue { // Is a UNIQUE value per response.
                        sign(devicePrivateKey, (clientDataHash || userCredentialId))
                                                            // userCredentialId is second because it is variable length
                    }

                    AuthDataForDevicePublicKeyAttestation: {
                        rpIdHash                // i.e., the "audience"
                        AAGUID                  // This is also in `attestedCredentialData`, but attested cred data
                                                // is not present in authentication assertions, so it needs to be
                                                // here IF we wish this devicePublicKey extension result to be the
                                                // same format whether it is returned as result of a registration
                                                // or authn request.
                        devicePublicKey         // The "attested" device public key.
                    }

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // contains various items depending upon the attestation statement format,
                                // Crucially containing a signature value, generated using
                                // the device's (effective) AttestationPrivatekey, over this to-be-signed data:

                        AuthDataForDevicePublicKeyAttestation   // SIGNED by AttestationPrivatekey.
                                                                // Crucially, this to-be-signed data does not include
                                                                // clientDataHash because the latter is specific to these
                                                                // current request, e.g., the hashed clientData includes
                                                                // the request challenge.
                                                                //
                                                                // Note: This `attStmt` is a CONSTANT value per context
                                                                // per device per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForRegistrationReturningDevicePublicKey

        ClientDataHash: {  // the following items are serialized then hashed to form this value:
            type
            challenge
            origin
            crossOrigin
        }

    } // EncompassingRegistrationAttestationToBeSigned



    EncompassingAuthenticationAssertionToBeSigned: {    // SIGNED by the user credential private key yielding the
                                                        // `AuthenticatorAssertionResponse.signature` value.
                                                        // This is only depicting what gets signed by which signing key,
                                                        // NOTE that the e.g. credentialID is conveyed unsigned in the
                                                        // PublicKeyCredential object.

        AuthDataForAuthenticationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            // NOTE: there is no `attestedCredentialData` in the authData conveyed in an assertion

            extensions: {

                devicePublicKeyExtensionResult: {

                    dpkSignatureValue { // Is a UNIQUE value per response. SIGNED
                        sign(devicePrivateKey, (clientDataHash || userCredentialId))
                                                            // userCredentialId is second because it is variable length
                    }

                    AuthDataForDevicePublicKeyAttestationToBeSigned: {
                        rpIdHash               // i.e., the "audience"
                        AAGUID
                        devicePublicKey
                    }

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // Contains various items depending upon the attestation statement format,
                                // crucially containing a signature value, generated using the device's (effective)
                                // AttestationPrivatekey, over this to-be-signed data:
                        AuthDataForDevicePublicKeyAttestation
                                //
                                // Crucially, this to-be-signed data DOES NOT INCLUDE
                                // `clientDataHash` because the latter is specific to this
                                // current request, e.g., the hashed clientData includes
                                // the request challenge.
                                //
                                // NOTE: This `attStmt` is a CONSTANT value per context per device
                                // per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForAuthenticationReturningDevicePublicKey

        ClientDataHash: {  // the following items are serialized then hashed to form this value:
            type
            challenge
            origin
            crossOrigin
        }

    } // EncompassingAuthenticationAssertionToBeSigned



****)

(* ProVerif Web Authentication Formal Model
   originally by Iness Ben Guirat and Harry Halpin
   Paper: https://dl.acm.org/doi/10.1145/3190619.3190640
   Slides: https://cps-vo.org/node/48511
   github: https://github.com/hhalpin/weauthn-model
*)

(**** webauthn-basic.pv ****

See the paper section 5.2 for a detailed description of this model.

In summary: This models first registration of a WebAuthn user credential with a server (aka Relying Party) and then subsequent authentication using that registered credential.  The model seeks to prove various properties of the protocol.

Updated by Jeff Hodges with corrections and comments, May 2021
http://kingsmountain.com/people/jeff.hodges/
****)


free c:channel.  (* TLS channel *)

type AttestationPublicKey.
type AttestationPrivatekey.

type nonce.

type pkey.    (* asymmetric public key *)
type skey.    (* asymmetric secret key *)

type RP_id.
type key.     (* symmetric key *)



(***** For Digital Signatures *****)
(*                                                            *)
(*  This model of signatures assumes that the signature is    *)
(*  always accompanied with the message x.                    *)

fun spk(skey):pkey.
fun sign(bitstring, skey):bitstring.

reduc forall x:bitstring, y:skey; getmess(sign(x, y)) = x. (* The destructor getmess allows
                                                              the attacker to get the message
                                                              x from the signature, even
                                                              without having the key. *)

reduc forall x:bitstring, y:skey; checksign(sign(x, y), spk(y)) = x. (* The destructor
                                                                        checksign checks the signature,
                                                                        and returns x only when the
                                                                        signature is correct. Honest
                                                                        processes typically use only
                                                                        checksign. *)


(***** For nonces *****)

fun nonce_to_bitstring ( nonce ) : bitstring [ data , typeConverter ] .
table nonceTable(nonce) .


(***** For Digital signature over Attestation Credentials *****)
(*                                                            *)
(*  This model of signatures assumes that the signature is    *)
(*  always accompanied with the message x.                    *)

fun spkAtt(AttestationPrivatekey): AttestationPublicKey.
fun signAtt(bitstring, AttestationPrivatekey): bitstring.

reduc forall x:bitstring, y:AttestationPrivatekey; getmessAtt(signAtt(x, y)) = x. (* The destructor getmess allows
                                                                                     the attacker to get the message
                                                                                     x from the signature, even
                                                                                     without having the key. *)

reduc forall x:bitstring, y:AttestationPrivatekey; checksignAtt(signAtt(x, y), spkAtt(y)) = x. (* The destructor
                                                                                    checksign checks the signature,
                                                                                    and returns x only when the
                                                                                    signature is correct. Honest
                                                                                    processes typically use only
                                                                                    checksign. *)

free attskU: AttestationPrivatekey [private].
free attpkU: AttestationPublicKey [private].

(* originally:
free attpkU: AttestationPrivatekey [private]. -- BUG?: should be type AttestationPublicKey ?
                                                 Corrected above *)



free k: key [private].  (* TLS symmetric encryption key *)



(***** Symetric encryption *****)

fun senc(bitstring, key): bitstring.
reduc forall x: bitstring, k: key; sdec(senc(x,k),k) = x.


(***** User's ID  and Server's ID *****)

const cookie:bitstring [private].
const attestation_cert:bitstring [private].
const a: RP_id [private].



(***** Events and Queries *****)

event sentChallengeResponse(bitstring, bitstring).
event validChallengeResponse(bitstring, bitstring).
query N:bitstring, s:bitstring; event(validChallengeResponse(N, s)) ==> event(sentChallengeResponse(N, s)).

(* query N:bitstring; event(reachAuthentication(N)).
event reachAuthentication(bitstring). *)

query attacker(attskU).
query attacker(attpkU).
query attacker(k).



(***** Processes *****)

let processUser ( k: key, attskU: AttestationPrivatekey, attpkU:AttestationPublicKey, attestation_cert:bitstring) =

    (* Registration *)

    in(c, s:bitstring);
    let (challengeU:nonce, a:RP_id) = sdec(s,k) in

    new skU: skey;          (* mint new user credential "secret key user" |skU| *)
    let pkU = spk(skU) in   (* and "public key user" |pkU|                      *)

    out(c,                  (* return
        senc( ( attestation_cert, signAtt( (pkU, attpkU, challengeU), attskU ) ), k)
       );


    (* Authentication *)
    in(c, s1:bitstring);
    let mess1 = sdec(s1, k) in

    (* originally:
        event sentChallengeResponse( mess1, sign( senc(mess1,k), skU ) ); -- AFAICT, this and..
        out(c, sign(senc(mess1,k), skU)).     -- ..this are incorrectly constructed! The message needs to be enc'd
                                              -- using `k`, with the sig (by skU) inside.  (corrected below)
    *)

    event sentChallengeResponse( mess1, senc( sign(mess1, skU), k) );
    out(c,
        senc( sign(mess1, skU), k)
       ).



let processServer (k: key, a:RP_id) =

    (* Registration *)

    new challenge1:nonce;
    out(c, senc((challenge1, a), k));   (* send registration request *)
    in(c, s:bitstring);                 (* receive possible registration response *)

    let m = sdec(s,k) in
    let (cert:bitstring, pkY1: pkey, attpkU1:AttestationPublicKey, credUser: bitstring, Nt:nonce) = getmessAtt(m) in
                                            (* if the above succeeds, we received a registration response *)
    let ver = checksignAtt(m, attpkU1) in   (* verify signature on attestation response *)

    if (Nt=challenge1) then (  (* if we got here, then the signature on the registration response msg verified,
                                  and if the challenge returned matches the one we sent, then we will proceed
                                  to challenge the user to authenticate (not an actually typical server behavior,
                                  this just simplifies the model). *)

        (* Authentication *)

        new challenge2:nonce;
        let mess = nonce_to_bitstring( challenge2 ) in
        out(c, senc( (mess, a), k) );    (* authentication request with `challenge2` as `mess`   *)

        (****     for each of next 4 lines: local var | what client sent and thus local var is set to      *)
        (*                                ------------|----------------------------------------------      *)
        in(c, s2:bitstring);             (*     s2    |   senc( sign(mess1, skU), k )                      *)
        let m1 = sdec(s2, k) in          (*     m1    |   sign( mess1, skU )                               *)
        let m2 = checksign(m1, pkY1) in  (*     m2    |   mess1 (_should_ be `(mess,a)` if sig is valid)   *)
                                         (*           |                                                    *)
        let m3 = getmess(m1) in          (*     m3    |   mess1 (tho server sent `(mess,a)`) in out() above*)

        if ( m3 = m2 ) then (            (* This check is necessary (?) in order to determine if the       *)
                                         (* signed msg is actually the expected one.                       *)
                                         (* Perhaps should use for the preceding "let" and this "if":      *)
                                         (*           let (Nbitstr:bitstring, a1:RP_id) = getmess(m1) in   *)
                                         (*           if ((Nbitstr = mess) && (a1 = a)) then ( ... )   (?) *)
            event validChallengeResponse(m3, m2)
        )

        (* originally:
            in(c, s2:bitstring);
            let m1 = sdec(s2, k) in     -- this does not match how the (incorrectly written) client is
                                        -- constructing the msg to be rec'd here. (corrected above)
            let m2 = checksign(m1, pkY1) in
            let m3 = getmess(s2) in     -- this does match the client's (incorrect) construction (corrected above)
            if ( m3 = getmess(s2)) then (
                event validChallengeResponse(m3, s2)
            )
        *)
    )
    .


process
  new k: key; (* assume TLS handshake is error-free and yields this symmetric channel encryption key *)
  new attskU: AttestationPrivatekey; (* assume a particular authenticator with a particular attestation
                                        private key *)

  let attpkU = spkAtt(attskU) in
  (
    !processUser(k, attskU, attpkU, attestation_cert) | !processServer(k, a)
  )


(***** END *****)
