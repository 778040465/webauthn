(****** for the proverif model, find section entitled "ProVerif Web Authentication Formal Model" below...  ******)


(**** Device-bound Public Key | Device-bound Key Pair | Device key | Context Key | Secondary Key ****


==== WebAuthn Authenticator Response Messages, which include:                       ====
====   Collected Client Data, Attestation Object, Authenticator Data structures,    ====
====   and (nested) signature values calculated over portions of them.              ====


    // Coalesced informal expansion of PublicKeyCredential (showing all the important internal components
    // and eliminating (irrelevant) nested containers):


    Coalesced Registration PublicKeyCredential {
        id                      // User CredentialID
        clientDataJSON          // serialized collected client data
        attestationObject {     // `attObj` goes here
            authenticatorData {     // `authData` goes here
                        rpIdHash
                        flags
                        signCount
                        AAGUID
                        CredIDLength
                        CredentialID
                        CredentialPublicKey // User Credential Public Key
                        extensions          // devicePublicKey extension output will be in here
                     }
            fmt
            attStmt             // typically contains the ENCOMPASSING SIGNATURE VALUE of
                                // sign((authData, clientDataHash), AttestationPrivatekey)
        }
    }

    Coalesced Authentication PublicKeyCredential {
        id                      // User CredentialID
        clientDataJSON          // serialized collected client data
        authenticatorData {     // `authData` goes here
            rpIdHash
            flags
            signCount
            extensions          // devicePublicKey extension output will be in here
        }
        signature           // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
    }



    // Top-level WebAuthn response messages (expressed in simplified WebIDL):

    interface PublicKeyCredential : Credential {
        USVString               id;        // User Credential ID
        AuthenticatorResponse   response;
        [...]
    };

    interface AuthenticatorResponse {
        ArrayBuffer      clientDataJSON;    // serialized collected client data, included
                                            // in both .create() and .get() responses
    };

    interface AuthenticatorAttestationResponse : AuthenticatorResponse {  // .create() "Registration" response
        ArrayBuffer      attestationObject;  // `attObj` goes here, it contains the `authData` and other components
        [...]
    };

    interface AuthenticatorAssertionResponse : AuthenticatorResponse {    // .get() "Authentication" response
        ArrayBuffer      authenticatorData;  // `authData` goes here
        ArrayBuffer      signature;          // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
                                             // Note that the signed-over authData conveys extension results
        [...] // userHandle
    };



    // Authenticator Data (authData) in RFC5234 ABNF <https://www.w3.org/TR/webauthn/#authenticator-data>:

    authData = rpIdHash flags signCount [attestedCredentialData] [extensions]

        rpIdHash                = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        flags                   = OCTET
        signCount               = 4OCTET    ; 32-bit unsigned big-endian integer

        attestedCredentialData  = AAGUID CredIDLength CredentialID CredentialPublicKey

            AAGUID                  = 16OCTET   ; 16 octets
            CredIDLength            = 2OCTET    ; 16-bit unsigned big-endian integer
            CredentialID            = 16*OCTET  ; CredIDLength octets, at least 16 octets long
            CredentialPublicKey     = 1*OCTET   ; "user credential": self-describing variable length,
                                                ;  COSE_Key format (CBOR-endoded)

        extensions              = 1*OCTET   ; variable-length CBOR map of extension outputs
                                            ; `devicePublicKey` extension ouput is in here.



    // Attestation Object (attObj) in CDDL <https://www.w3.org/TR/webauthn-2/#sctn-generating-an-attestation-object>

    attObj = {
                authData: bytes,
                $$attStmtType
            }

    attStmtTemplate .within $$attStmtType

    attStmtTemplate = ( ; Every attestation statement format must have these fields:
                          fmt: text,
                          attStmt: { * tstr => any } ; Map is filled in by each concrete attStmtType

                        ; in most formats, the attStmt contains a signature value of:
                        ;   sign (authData || clientDataHash
                      )


    // `clientDataHash` is the hash of the serialized CollectedClientData object for the current registration
    // or authentication operation (expressed in WebIDL):

        dictionary CollectedClientData {
            required DOMString           type;      // "webauthn.create" or "webauthn.get", as appropriate
            required DOMString           challenge; // from RP's server
            required DOMString           origin;    // https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
            boolean                      crossOrigin;
            // tokenBinding optionally goes here
        }



==== Proposed Collected Syntax for devicePublicKey (dpk) (aka Secondary Key aka Device Key) Extension Output ====

    $$extensionOutput //= (                         // Expressed in CDDL
        devicePublicKey: AttObjForDevicePublicKey,
    )

    AttObjForDevicePublicKey = { ; Note: This object conveys an attested device public key
                                 ; and is analogous to `attObj`.

        dpkSignatureValue: bstr, ; result of sign((clientDataHash || userCredentialId), devicePrivateKey)
                                 ; Note that this sig value changes per-request because clientDataHash contains
                                 ; the per-request challenge.

        authDataForDevicePublicKeyAttestation: bstr,    ; AuthDataForDevicePublicKeyAttestation goes here

        $$attStmtType,      ; see <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object>.
                            ;
                            ; Attestation statement formats define the `fmt` and `attStmt` members of
                            ; $$attStmtType.
                            ;
                            ; In summary, it contains (1) a signature value calculated (using the attestation private key)
                            ; over just the bytes of `authDataForDevicePublicKeyAttestation`, and (2) the attestation
                            ; certificate or public key, and supporting certificates, if any. Note
                            ; that there are details dependent upon the particular attestation statement
                            ; format. See <https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats>.
    }


    AuthDataForDevicePublicKeyAttestation = rpIdHash AAGUID devicePublicKey
                                            ; Expressed in RFC5234 ABNF:

        rpIdHash                  = 32OCTET   ; SHA-256 hash of the RP ID the device key pair is scoped to
        AAGUID                    = 16OCTET   ; authenticator's AAGUID
        devicePublicKey           = 1*OCTET   ; self-describing variable length, COSE_Key format (CBOR-endoded)




==== WebAuthn Signed Objects Hierarchy for Device-bound Key Pair aka Device-bound Public Key aka Secondary Key aka Device Key ====

    AuthData for Registration and Authentication Operations returning a devicePublicKey extension response (expressed in RFC5234 ABNF; https://www.w3.org/TR/webauthn/#sctn-authenticator-data ):

        ; See WebAuthn-standard `authData` (above) for details, though NOTE that in these two `authData` instantiations
        ; the `extensions` component is ALWAYS included because the `AttObjForDevicePublicKey` is always conveyed
        ; in the `extensions` component:

        AuthDataForRegistrationReturningDevicePublicKey   = rpIdHash flags signCount attestedCredentialData extensions

        AuthDataForAuthenticationReturningDevicePublicKey = rpIdHash flags signCount extensions


    Registration:

    Encompassing Attestation Object `attObj` <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object> is returned by the Registration Operation (in `AuthenticatorAttestationResponse.attestationObject`). This `attObj` attests the user credential, and signs over `AuthDataForRegistrationReturningDevicePublicKey`. The latter object's `extensions` field contains the `devicePublicKey` extension output (see above):

        AuthenticatorAttestationResponse: {
            clientDataJSON
            attestationObject
        }

        attObj = {
                    AuthDataForRegistrationReturningDevicePublicKey: bytes, ; devicePublicKey extension result is here
                    $$attStmtType   ; as defined in WebAuthn, contains ENCOMPASSING SIGNATURE VALUE over:
                                    ; authData || clientDataHash
                }


    Authentication:

    Encompassing Authentication Assertion is returned by the Authentication Operation (as `AuthenticatorAssertionResponse`). The "assertion" is the `signature` value over the concatenation of the `AuthDataForAuthenticationReturningDevicePublicKey` and the hash of the collected client data containing the RP's challenge. `AuthDataForAuthenticationReturningDevicePublicKey`'s `extensions` field contains the `devicePublicKey` extension output:

        AuthenticatorAssertionResponse: {  // expressed in bespoke informal notation
            clientDataJSON
            AuthDataForAuthenticationReturningDevicePublicKey
            signature       // ENCOMPASSING SIGNATURE VALUE over:
                            //   AuthDataForAuthenticationReturningDevicePublicKey || clientDataHash
        }


    ==== To-Be-Signed Data for the ENCOMPASSING SIGNATURE VALUEs (expressed in bespoke informal notation):

    EncompassingRegistrationAttestationToBeSigned: {    // SIGNED by the attestation private key to form the signature
                                                        // value returned in the top-level attestation statement.
                                                        // This is only depicting what gets signed by which signing key,
                                                        // NOTE that the e.g. credentialID is conveyed unsigned in the
                                                        // PublicKeyCredential object.

        AuthDataForRegistrationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            attestedCredentialData: {
                AAGUID
                CredIDLength
                CredentialID        // user credential ID
                CredentialPublicKey // "user credential"
            }

            extensions: {

                devicePublicKeyExtensionResult: {

                    dpkSignatureValue { // Is a UNIQUE value per response. SIGNED by devicePrivateKey.
                        sign((clientDataHash || userCredentialId), devicePrivateKey)
                                                            // userCredentialId is second because it is variable length
                    }

                    AuthDataForDevicePublicKeyAttestation: {
                        rpIdHash                // i.e., the "audience"
                        AAGUID                  // This is in `attestedCredentialData`, but attested cred data
                                                // is not present in authentication assertions, so it needs to be
                                                // here IF we wish this devicePublicKey extension result to be the
                                                // same format whether it is returned as result of a registration
                                                // or authn request.
                        devicePublicKey         // The "attested" device public key.
                    }

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // contains various items depending upon the attestation statement format,
                                // Crucially containing a signature value, generated using
                                // the device's (effective) AttestationPrivatekey, over this to-be-signed data:

                        AuthDataForDevicePublicKeyAttestation   // SIGNED by AttestationPrivatekey.
                                                                // Crucially, this to-be-signed data does not include
                                                                // clientDataHash because the latter is specific to these
                                                                // current request, e.g., the hashed clientData includes
                                                                // the request challenge.
                                                                //
                                                                // Note: This `attStmt` is a CONSTANT value per context
                                                                // per device per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForRegistrationReturningDevicePublicKey

        ClientDataHash: {  // the following items are serialized then hashed to form this value:
            type
            challenge
            origin
            crossOrigin
        }

    } // EncompassingRegistrationAttestationToBeSigned



    EncompassingAuthenticationAssertionToBeSigned: {    // SIGNED by the user credential private key yielding the
                                                        // `AuthenticatorAssertionResponse.signature` value.
                                                        // This is only depicting what gets signed by which signing key,
                                                        // NOTE that the e.g. credentialID is conveyed unsigned in the
                                                        // PublicKeyCredential object.

        AuthDataForAuthenticationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            // NOTE: there is no `attestedCredentialData` in the authData conveyed in an assertion

            extensions: {

                devicePublicKeyExtensionResult: {

                    dpkSignatureValue { // Is a UNIQUE value per response. SIGNED by devicePrivateKey.
                        sign((clientDataHash || userCredentialId), devicePrivateKey)
                            // userCredentialId is second because it is variable length
                    }

                    AuthDataForDevicePublicKeyAttestationToBeSigned: {
                        rpIdHash                // i.e., the "audience"
                        AAGUID                  // Needs to be here because if user cred is synced to "new" device
                                                // a registration is not done on that device and the RP will receive
                                                // a new devicePublicKey extension result from a get() call, and
                                                // this will attest to the provenance of the authenticator.
                        devicePublicKey         // The "attested" device public key.
                    }

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // Contains various items depending upon the attestation statement format,
                                // crucially containing a signature value, generated using the device's (effective)
                                // AttestationPrivatekey, over this to-be-signed data:
                        AuthDataForDevicePublicKeyAttestation
                                //
                                // Crucially, this to-be-signed data DOES NOT INCLUDE
                                // `clientDataHash` because the latter is specific to this
                                // current request, e.g., the hashed clientData includes
                                // the request challenge.
                                //
                                // NOTE: This `attStmt` is a CONSTANT value per context per device
                                // per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForAuthenticationReturningDevicePublicKey

        ClientDataHash: {  // the following items are serialized then hashed to form this value:
            type
            challenge
            origin
            crossOrigin
        }

    } // EncompassingAuthenticationAssertionToBeSigned



****)

(* ProVerif Web Authentication Formal Model
   originally by Iness Ben Guirat and Harry Halpin
   Paper: https://dl.acm.org/doi/10.1145/3190619.3190640
   Slides: https://cps-vo.org/node/48511
   github: https://github.com/hhalpin/weauthn-model
*)

(**** webauthn-basic.pv ****

See the paper section 5.2 for a detailed description of this model.

In summary: This models first registration of a WebAuthn user credential with a server (aka Relying Party) and then subsequent authentication using that registered credential.  The model seeks to prove various properties of the protocol.

Updated by Jeff Hodges with corrections and comments, May 2021
http://kingsmountain.com/people/jeff.hodges/
****)

#include "crypto.pvl"
#include "named_tuples.pvl"

free c:channel.  (* TLS channel *)


type nonce.

(***** Server's ID *****)

type RP_id.
const a: RP_id [private].

(***** Attestation Key Pair *****

free attSecretKey: SKey [private].
free attPublicKey: PKey [private].


(***** Server's and authnr+clientPlatform's tuple messages *****)

(* authnr+clientPlatform returns this to server: *)
DEFINE_DATA_TYPE4(RegResponseMsg,
                  userCredPubKey, PKey,
                  attPublicKey, PKey,
                  receivedRegChallenge, nonce,
                  attSignature, bitstring).

fun RegResponseMsg2b( RegResponseMsg ): bitstring [data , typeConverter].
fun B2RegResponseMsg( bitstring ): RegResponseMsg [data , typeConverter].


(* server sends this: *)
DEFINE_DATA_TYPE2(AuthnRequestMsg,
                  authnChallenge, nonce,
                  serverName, RP_id).

fun AuthnRequestMsg2b( AuthnRequestMsg ): bitstring [data , typeConverter].
fun B2AuthnRequestMsg( bitstring ): AuthnRequestMsg [data , typeConverter].


(* user's authnr+clientPlatform returns this to server: *)
DEFINE_DATA_TYPE3(AuthnResponseMsg,
                  returnedAuthnChallenge, nonce,
                  serverName, RP_id,
                  assertSignature, bitstring).

fun AuthnResponseMsg2b( AuthnResponseMsg ): bitstring [data , typeConverter].
fun B2AuthnResponseMsg( bitstring ): AuthnResponseMsg [data , typeConverter].



free tlsKey: Key [private].  (* TLS symmetric encryption key *)




(***** Events and Queries *****)

event sentChallengeResponse(bitstring, bitstring).
event validChallengeResponse(bitstring, bitstring).

(* we can only receive a valid response if the user sent a response message *)
query N:bitstring, s:bitstring; event(validChallengeResponse(N, s)) ==> event(sentChallengeResponse(N, s)).

(* query N:bitstring; event(reachAuthentication(N)).
event reachAuthentication(bitstring). *)

(* query attacker(attSecretKey). *)
(* query attacker(attPublicKey). *)
query attacker(tlsKey).



(***** Processes *****)

let processUser ( k: Key, attskU: SKey, attpkU: PKey) =

    (* Registration *)

    in(c, s:bitstring);
    let (challengeU:nonce, a:RP_id) = dec(s,k) in

    new skU: SKey;          (* mint new user credential "secret key user" |skU| *)
    let pkU = pk(skU) in    (* and "public key user" |pkU|                      *)

    let regResponseMsg = BuildRegResponseMsg(pkU, attpkU, challengeU, sign((pkU, challengeU), attskU)) in
    let regResponseMsgb = RegResponseMsg2b(regResponseMsg) in

    out(c,                  (* return registration response with attestation *)
        enc(regResponseMsgb, k)
       );


    (* Authentication *)

    in(c, encAuthnRequestMsg: bitstring);   (* receive server's challenge. *)
    let authnRequestMsgb = dec(encAuthnRequestMsg, k) in
    let authnRequestMsg = B2AuthnRequestMsg(authnRequestMsgb) in
    let receivedAuthnChallenge = AuthnRequestMsg_authnChallenge(authnRequestMsg) in
    let receivedServerName = AuthnRequestMsg_serverName(authnRequestMsg) in

    let assertionSignature = sign((receivedAuthnChallenge, receivedServerName), skU) in
    let authnResponseMsg = BuildAuthnResponseMsg(receivedAuthnChallenge, receivedServerName, assertionSignature) in
    let authnResponseMsgb = AuthnResponseMsg2b(authnResponseMsg) in

    event sentChallengeResponse( authnResponseMsgb, enc(authnResponseMsgb, k) );
    out(c,
        enc(authnResponseMsgb, k)
       ).



let processServer (k: Key, a: RP_id) =

    (* Registration *)

    new regChallenge: nonce;

    out(c, enc((regChallenge, a), k));        (* send registration request *)
    in(c, encRegResponseMsg: bitstring);      (* receive possible registration response *)

    let regResponseMsgb = dec(encRegResponseMsg, k) in (* decrypt and parse |encRegResponseMsg| *)
    let regResponseMsg = B2RegResponseMsg(regResponseMsgb) in
    let userPK = RegResponseMsg_userCredPubKey(regResponseMsg) in
    let attPK = RegResponseMsg_attPublicKey(regResponseMsg) in
    let returnedRegChallenge = RegResponseMsg_receivedRegChallenge(regResponseMsg) in
    let attSig = RegResponseMsg_attSignature(regResponseMsg) in

    if checkSign(attSig, (userPK, returnedRegChallenge), attPK) then (* we have a registration response msg with
                                                                        a valid signature... *)

    if (regChallenge = returnedRegChallenge) then (  (* ...and if the challenge returned matches the  then we
                                                          one we sent, will proceed to challenge the user to
                                                          authenticate. *)

        (* Authentication *)

        new authnChallenge: nonce;

        (* let authnChallengeBitstr = nonce_to_bitstring( authnChallenge ) in  -- do we need to do this type conversion? *)

        let authnRequestMsg = BuildAuthnRequestMsg(authnChallenge, a) in
        let authnRequestMsgb = AuthnRequestMsg2b(authnRequestMsg) in

        out(c, enc( authnRequestMsgb, k) );     (* send authentication request *)

        in(c, encAuthnResponseMsg: bitstring);
        let authnResponseMsgb = dec(encAuthnResponseMsg, k) in
        let authnResponseMsg = B2AuthnResponseMsg(authnResponseMsgb) in
        let retAuthnChallenge = AuthnResponseMsg_returnedAuthnChallenge(authnResponseMsg) in
        let retServerName = AuthnResponseMsg_serverName(authnResponseMsg) in
        let retAssertSignature = AuthnResponseMsg_assertSignature(authnResponseMsg) in

        if (authnChallenge = retAuthnChallenge) && (a = retServerName) then
        if checkSign(retAssertSignature, (retAuthnChallenge, retServerName), userPK) then

        event validChallengeResponse(authnResponseMsgb, encAuthnResponseMsg)
        ).



process
  new tlsKey: Key; (* assume TLS handshake is error-free and yields this symmetric channel-encryption key *)
  new attSecretKey: SKey; (* assume a particular authenticator with a particular attestation
                                              private key *)

  let attPublicKey = pk(attSecretKey) in
  (
    !processUser(tlsKey, attSecretKey, attPublicKey) | !processServer(tlsKey, a)
  )


(***** END *****)
