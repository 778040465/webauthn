


==== Proposed Syntax for devicePublicKey (dpk) (aka Secondary Key aka Device Key) Extension Output ====

$$extensionOutput //= (                       ; Expressed in CDDL
    devicePubKey: AttObjForDevicePublicKey,
)

AttObjForDevicePublicKey = { ; Note: This object conveys an attested device public key
                             ; and is analogous to `attObj`.

    sig:    bstr,  ; result of sign((clientDataHash || userCredentialId), devicePrivateKey)
                   ; Note that this sig value is unique per-response because the client data
                   ; contains the per-request challenge.

    aaguid: bstr,  ; authenticator's AAGUID
                   ; (16 bytes fixed-length <https://www.w3.org/TR/webauthn/#aaguid>).

    dpk:    bstr,  ; the Device Public Key
                   ; (self-describing variable length, COSE_Key format (CBOR-encoded)).

    $$attStmtType, ; see <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object>.
                   ;
                   ; Attestation statement formats define the `fmt` and `attStmt` members of
                   ; $$attStmtType.
                   ;
                   ; In summary, the `attStmt` will (typically) contain:
                   ;   (1) a SIGNATURE value calculated (using the attestation private key)
                   ;       over (aaguid || dpk).
                   ;   (2) the attestation certificate or public key, and supporting certificates,
                   ;       if any.
                   ;
                   ; Note that there are details dependent upon the particular attestation
                   ; statement format.
                   ; See <https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats>.
}





==== SUPPORTING INFORMATION and MUSINGS:

==== WebAuthn Authenticator Response Messages, which include:                       ====
====   Collected Client Data, Attestation Object, Authenticator Data structures,    ====
====   and (nested) signature values calculated over portions of them.              ====


    // Coalesced informal expansion of PublicKeyCredential (showing all the important internal components
    // and eliminating (irrelevant) nested containers):


    Coalesced Registration PublicKeyCredential {
        id                      // User CredentialID
        clientDataJSON          // serialized collected client data
        attestationObject {     // `attObj` goes here
            authenticatorData {     // `authData` goes here
                        rpIdHash
                        flags
                        signCount
                        AAGUID
                        CredIDLength
                        CredentialID
                        CredentialPublicKey // User Credential Public Key
                        extensions          // devicePublicKey extension output will be in here
                     }
            fmt
            attStmt             // typically contains the ENCOMPASSING SIGNATURE VALUE of
                                // sign((authData || clientDataHash), AttestationPrivatekey)
        }
    }

    Coalesced Authentication PublicKeyCredential {
        id                      // User CredentialID
        clientDataJSON          // serialized collected client data
        authenticatorData {     // `authData` goes here
            rpIdHash
            flags
            signCount
            extensions          // devicePublicKey extension output will be in here
        }
        signature           // ENCOMPASSING SIGNATURE VALUE of
                            // sign((authData || clientDataHash), CredentialPublicKey)
    }



    // Top-level WebAuthn response messages (expressed in simplified WebIDL):

    interface PublicKeyCredential : Credential {
        USVString               id;        // User Credential ID
        AuthenticatorResponse   response;
        [...]
    };

    interface AuthenticatorResponse {
        ArrayBuffer      clientDataJSON;    // serialized collected client data, included
                                            // in both .create() and .get() responses
    };

    interface AuthenticatorAttestationResponse : AuthenticatorResponse {  // .create() "Registration" response
        ArrayBuffer      attestationObject;  // `attObj` goes here, it contains the `authData` and other components
        [...]
    };

    interface AuthenticatorAssertionResponse : AuthenticatorResponse {    // .get() "Authentication" response
        ArrayBuffer      authenticatorData;  // `authData` goes here
        ArrayBuffer      signature;          // ENCOMPASSING SIGNATURE VALUE over: authData || clientDataHash
                                             // Note that the signed-over authData conveys extension results
        [...] // userHandle
    };



    // Authenticator Data (authData) in RFC5234 ABNF <https://www.w3.org/TR/webauthn/#authenticator-data>:

    authData = rpIdHash flags signCount [attestedCredentialData] [extensions]

        rpIdHash                = 32OCTET   ; SHA-256 hash of the RP ID the credential is scoped to
        flags                   = OCTET
        signCount               = 4OCTET    ; 32-bit unsigned big-endian integer

        attestedCredentialData  = AAGUID CredIDLength CredentialID CredentialPublicKey

            AAGUID                  = 16OCTET   ; 16 octets
            CredIDLength            = 2OCTET    ; 16-bit unsigned big-endian integer
            CredentialID            = 16*OCTET  ; CredIDLength octets, at least 16 octets long
            CredentialPublicKey     = 1*OCTET   ; "user credential": self-describing variable length,
                                                ;  COSE_Key format (CBOR-endoded)

        extensions              = 1*OCTET   ; variable-length CBOR map of extension outputs
                                            ; `devicePublicKey` extension ouput is in here.



    // Attestation Object (attObj) in CDDL <https://www.w3.org/TR/webauthn-2/#sctn-generating-an-attestation-object>

    attObj = {
                authData: bytes,
                $$attStmtType
            }

    attStmtTemplate .within $$attStmtType

    attStmtTemplate = ( ; Every attestation statement format must have these fields:
                          fmt: text,
                          attStmt: { * tstr => any } ; Map is filled in by each concrete attStmtType

                        ; in most formats, the attStmt contains a signature value of:
                        ;   sign (authData || clientDataHash
                      )


    // `clientDataHash` is the hash of the serialized CollectedClientData object for the current registration
    // or authentication operation (expressed in WebIDL):

        dictionary CollectedClientData {
            required DOMString           type;      // "webauthn.create" or "webauthn.get", as appropriate
            required DOMString           challenge; // from RP's server
            required DOMString           origin;    // https://html.spec.whatwg.org/#ascii-serialisation-of-an-origin
            boolean                      crossOrigin;
            // tokenBinding optionally goes here
        }



==== (OLD, SUPERSEDED) Proposed Syntax for devicePublicKey (dpk) (aka Secondary Key aka Device Key) Extension Output
==== (EXPRESSES RATIONALE) (see further below for current actual dpk proposed syntax...

    $$extensionOutput //= (                        ; Expressed in CDDL
        devicePublicKey: AttObjForDevicePublicKey,
    )

    AttObjForDevicePublicKey = { ; Note: This object conveys an attested device public key
                                 ; and is analogous to `attObj`.

        dpkSignatureValue: bstr, ; result of sign((clientDataHash || userCredentialId), devicePrivateKey)
                                 ; Note that this sig value is unique per-request because clientDataHash contains
                                 ; the per-request challenge.

        authDataForDevicePublicKeyAttestation: bstr, ; AuthDataForDevicePublicKeyAttestation goes here (see below)

        $$attStmtType,      ; see <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object>.
                            ;
                            ; Attestation statement formats define the `fmt` and `attStmt` members of
                            ; $$attStmtType.
                            ;
                            ; In summary, the `attStmt` contains:
                            ;   (1) a SIGNATURE value calculated (using the attestation private key)
                            ;       over the bytes of (authDataForDevicePublicKeyAttestation ||Â rpIdHash), and
                            ;   (2) the attestation certificate or public key, and supporting certificates, if any.
                            ;
                            ; Note that there are details dependent upon the particular attestation statement
                            ; format. See <https://www.w3.org/TR/webauthn/#sctn-defined-attestation-formats>.
    }


    AuthDataForDevicePublicKeyAttestation = AAGUID devicePublicKey ; Expressed in RFC5234 ABNF:

      ; A rationale for also including `rpIdHash` here is so `AttObjForDevicePublicKey.attStmt`
      ; is "self contained", i.e., so that the verifier would not need to "look elsewhere" in order
      ; to verify the signature.
      ; rpIdHash                  = 32OCTET   ; SHA-256 hash of the RP ID the device key pair is scoped to
      ; HOWEVER, including rpIdHash here can make a substitution of the authDataForDevicePublicKeyAttestation "easier" because
      ; then it could differ from the rpIdHash in the top-level message.

      ; Do we also include these next two items here such that the `AttObjForDevicePublicKey.attStmt` is self-contained?
      ; I.e., the verifier would not need to "look elsewhere" in order to have the data necessary for signature
      ; verification
      ;
      ; CredIDLength              = 2OCTET    ; 16-bit unsigned big-endian integer
      ; CredentialID              = 16*OCTET  ; CredIDLength octets, at least 16 octets long
      ;
      ; note-to-self: ANSWER TO ABOVE IS "no" wrt CredID because otherwise we'd also need to include the clientDataHash
      ; and this is just plain getting unnecessarily too large.  plus credID is only needed to validate dpkSignatureValue.

        AAGUID                    = 16OCTET   ; authenticator's AAGUID
        devicePublicKey           = 1*OCTET   ; self-describing variable length, COSE_Key format (CBOR-encoded)

      ; Another question here is whether for this `AuthDataForDevicePublicKeyAttestation` continues the tradition of an
      ; undelimited bespoke binary format, or whether we encode it in CBOR ?




==== WebAuthn Signed Objects Hierarchy for Device-bound Key Pair aka Device-bound Public Key aka Secondary Key aka Device Key ====

    AuthData for Registration and Authentication Operations returning a devicePublicKey extension response (expressed in RFC5234 ABNF; https://www.w3.org/TR/webauthn/#sctn-authenticator-data ):

        ; See WebAuthn-standard `authData` (above) for details, though NOTE that in these two `authData` instantiations
        ; the `extensions` component is ALWAYS included because the `AttObjForDevicePublicKey` is always conveyed
        ; in the `extensions` component:

        AuthDataForRegistrationReturningDevicePublicKey   = rpIdHash flags signCount attestedCredentialData extensions

        AuthDataForAuthenticationReturningDevicePublicKey = rpIdHash flags signCount extensions


    Registration:

    Encompassing Attestation Object `attObj` <https://www.w3.org/TR/webauthn/#sctn-generating-an-attestation-object> is returned by the Registration Operation (in `AuthenticatorAttestationResponse.attestationObject`). This `attObj` attests the user credential, and signs over `AuthDataForRegistrationReturningDevicePublicKey`. The latter object's `extensions` field contains the `devicePublicKey` extension output (see above):

        AuthenticatorAttestationResponse: {
            clientDataJSON
            attestationObject
        }

        attObj = {
                    AuthDataForRegistrationReturningDevicePublicKey: bytes, ; devicePublicKey extension result is here
                    $$attStmtType   ; as defined in WebAuthn, contains ENCOMPASSING SIGNATURE VALUE over:
                                    ; authData || clientDataHash
                }


    Authentication:

    Encompassing Authentication Assertion is returned by the Authentication Operation (as `AuthenticatorAssertionResponse`). The "assertion" is the `signature` value over the concatenation of the `AuthDataForAuthenticationReturningDevicePublicKey` and the hash of the collected client data containing the RP's challenge. `AuthDataForAuthenticationReturningDevicePublicKey`'s `extensions` field contains the `devicePublicKey` extension output:

        AuthenticatorAssertionResponse: {  // expressed in bespoke informal notation
            clientDataJSON
            AuthDataForAuthenticationReturningDevicePublicKey
            signature       // ENCOMPASSING SIGNATURE VALUE over:
                            //   AuthDataForAuthenticationReturningDevicePublicKey || clientDataHash
        }


    ==== To-Be-Signed Data for the ENCOMPASSING SIGNATURE VALUEs (expressed in bespoke informal notation):

    EncompassingRegistrationAttestationToBeSigned: {    // SIGNED by the attestation private key to form the signature
                                                        // value returned in the top-level attestation statement.
                                                        // This is only depicting what gets signed by which signing key,
                                                        // NOTE that the e.g. credentialID is conveyed unsigned in the
                                                        // PublicKeyCredential object.

        AuthDataForRegistrationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            attestedCredentialData: {
                AAGUID
                CredIDLength
                CredentialID        // user credential ID
                CredentialPublicKey // "user credential"
            }

            extensions: {

                devicePubKey: {

                    sig: { // Is a UNIQUE value per response. SIGNED by devicePrivateKey.
                        sign((clientDataHash || userCredentialId), devicePrivateKey)
                                                            // userCredentialId is second because it is variable length
                    }

                    aaguid                  // This is in `attestedCredentialData`, but attested cred data
                                            // is not present in authentication assertions, so it needs to be
                                            // here IF we wish this devicePublicKey extension result to be the
                                            // same format whether it is returned as result of a registration
                                            // or authn request.
                    dpk         // The "attested" device public key.

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // contains various items depending upon the attestation statement format,
                                // Crucially containing a signature value, generated using
                                // the device's (effective) AttestationPrivatekey, over this to-be-signed data:

                        ( aaguid || dpk )                       // SIGNED by AttestationPrivatekey.
                                                                // Crucially, this to-be-signed data does not include
                                                                // clientDataHash because the latter is specific to these
                                                                // current request, e.g., the hashed clientData includes
                                                                // the request challenge.
                                                                //
                                                                // Note: This `attStmt` is a CONSTANT value per context
                                                                // per device per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForRegistrationReturningDevicePublicKey

        ClientDataHash: {  // the following items are serialized then hashed to form this value:
            type
            challenge
            origin
            crossOrigin
        }

    } // EncompassingRegistrationAttestationToBeSigned



    EncompassingAuthenticationAssertionToBeSigned: {    // SIGNED by the user credential private key yielding the
                                                        // `AuthenticatorAssertionResponse.signature` value.
                                                        // This is only depicting what gets signed by which signing key,
                                                        // NOTE that the e.g. credentialID is conveyed unsigned in the
                                                        // PublicKeyCredential object.

        AuthDataForAuthenticationReturningDevicePublicKey: {

            rpIdHash
            flags
            signCount

            // NOTE: there is no `attestedCredentialData` in the authData conveyed in an assertion

            extensions: {

                devicePubKey: {

                    sig: { // Is a UNIQUE value per response. SIGNED by devicePrivateKey.
                        sign((clientDataHash || userCredentialId), devicePrivateKey)
                                                            // userCredentialId is second because it is variable length
                    }

                    aaguid                  // This is in `attestedCredentialData`, but attested cred data
                                            // is not present in authentication assertions, so it needs to be
                                            // here IF we wish this devicePublicKey extension result to be the
                                            // same format whether it is returned as result of a registration
                                            // or authn request.
                    dpk         // The "attested" device public key.

                    fmt: "...attestation statement format identifier..."

                    attStmt: {  // contains various items depending upon the attestation statement format,
                                // Crucially containing a signature value, generated using
                                // the device's (effective) AttestationPrivatekey, over this to-be-signed data:

                        ( aaguid || dpk )                       // SIGNED by AttestationPrivatekey.
                                                                // Crucially, this to-be-signed data does not include
                                                                // clientDataHash because the latter is specific to these
                                                                // current request, e.g., the hashed clientData includes
                                                                // the request challenge.
                                                                //
                                                                // Note: This `attStmt` is a CONSTANT value per context
                                                                // per device per account per RP.
                    }
                }

                // potentially other extension results...

            } // extensions

        } // AuthDataForAuthenticationReturningDevicePublicKey

        ClientDataHash: {  // the following items are serialized then hashed to form this value:
            type
            challenge
            origin
            crossOrigin
        }

    } // EncompassingAuthenticationAssertionToBeSigned




==== end ====